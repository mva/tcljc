(ns tcljc.emitter
  (:require
   [tcljc.config :as cfg]
   [tcljc.classfile :as cf]
   [tcljc.runtime :as rt]
   [tcljc.wrong :as wrong]   
   [tcljc.reader :as rd]
   [tcljc.context :as ctx]
   [tcljc.expr :as x]
   [tcljc.predefined :as predefined]
   [tcljc.publics :as publics]
   [tcljc.emitter.beachhead :as beachhead]
   [tcljc.emitter.namespace :as nmsp]
   [tcljc.emitter.prepare :as prepare]
   [tcljc.emitter.bytecode :as bytecode]
   [tcljc.emitter.emitfn :as emitfn]
   [tcljc.emitter.classes :as classes]
   [tcljc.emitter.export :as export]
   [tinyclj.string :as str])
  (:import
   (tcljc.classfile CHR ClassDef)
   (tcljc.expr FnCode DeftypeDef MethodDef)
   (tcljc.emitter.namespace Namespace)
   (tcljc.emitter.emitfn FnSpec)
   (tcljc.emitter.prepare TlfSummary)
   (tcljc.context FnRequireNamespace Ctx Msg EmitQueue)
   (tcljc.expr Expr Binding BindingRef FnForm)
   (clojure.lang ISeq IPersistentMap IPersistentVector)
   (jdk.classfile Classfile ClassBuilder CodeBuilder TypeKind)
   (java.nio.file Path)
   (java.lang.constant ClassDesc MethodTypeDesc)
   (java.lang.invoke MethodHandles$Lookup MethodHandle)
   (java.util Map HashMap HashSet)
   (java.util.concurrent Future CompletableFuture ConcurrentHashMap
                         BlockingQueue ExecutorService)
   (java.util.function Consumer)))

(deftype BuildEnv
    [^ClassLoader app-ld
     ;; Source files are obtained from this loader via
     ;; `.getResource`.  If the parent classloader is
     ;; :system, then `app-ld` also provides ahead-of-time
     ;; compiled class files.  It must never return classes
     ;; from the destination directory, or compilation of
     ;; modified classes will silently stop.

     ^MethodHandles$Lookup rt-lookup
     ;; Classes and methods from module tinyclj.rt are
     ;; accessed via this lookup.

     ^IPersistentMap builtin-nmsp
     ;; Builtin namespaces that can be required directly from
     ;; any namespace (maps string -> Namespace).

     ^Path dest-dir
     ;; When set, then class files are also written to this
     ;; directory.
              
;;; Lifetime of single build run of "watch mode":
     ^ClassLoader dyn-ld
     ^CHR dyn-chr
              
;;; For unit tests:
     injected-file-forms      ;forms used in lieu of reading from file
     arender-to               ;maps class owner string to class data
     ]
  tcljc.emitter.namespace.IBuildEnv
  (rt-lookup [_]
    rt-lookup)
  (resolve-rpath [_ rpath]
    (if injected-file-forms
      (cfg/path-url rpath)
      (.getResource app-ld (str rpath))))
  (forms-reader [_ rurl]
    (if-some [xs (get injected-file-forms rurl)]
      (rd/mk-seq-reader xs)
      (rd/mk-reader (rd/tokenize rurl)))))

(defn mk-build-env
  (^BuildEnv [^ClassLoader app-ld  ^Path dest-dir ^ClassLoader dyn-ld
              ^IPersistentMap builtin-nmsp]
   (mk-build-env app-ld dest-dir dyn-ld builtin-nmsp nil nil))
  (^BuildEnv [^ClassLoader app-ld  ^Path dest-dir ^ClassLoader dyn-ld
              ^IPersistentMap builtin-nmsp injected-file-forms arender-to]
   (BuildEnv. app-ld (cfg/get-rt-lookup app-ld) builtin-nmsp dest-dir
              dyn-ld (cf/mk-chr dyn-ld)
              injected-file-forms arender-to)))

(def first-segm-id 100)
(def ns-class-name "__ns")

(deftype SegmState [^BuildEnv env
                    ^Ctx ctx
                    ^String source-file
                    
                    ^int segm-id
                    ^ClassDesc segm-cld
                    ^IPersistentVector summaryv ;of TlfSummary
                    
                    ^IPersistentVector bytesv ;nil if bytes are not tracked
                    ^Class prev-segment-class])

(defn- segment-lookup ^MethodHandles$Lookup [^SegmState segm]
  (-> segm .ctx .lookup-in-pkg))
(defn- segment-ns-str ^String [^SegmState segm]
  (-> segm .ctx .ns-str))
(defn- segment-name ^String [^SegmState segm ^int id-delta]
  (str (segment-ns-str segm) "." ns-class-name (+ (.segm-id segm) id-delta)))
(defn- segment-cld ^ClassDesc [^SegmState segm ^int id-delta]
  (if (zero? id-delta)
    (.segm-cld segm)
    (ClassDesc/of (segment-name segm id-delta))))
(defn- segment-chr ^CHR [^SegmState segm]
  (-> segm .env .dyn-chr))

(defn with-summary ^SegmState [^SegmState segm ^TlfSummary summary]
  (SegmState. (.env segm) (.ctx segm) (.source-file segm)
              (.segm-id segm) (.segm-cld segm) (conj (.summaryv segm) summary)
              (.bytesv segm) (.prev-segment-class segm)))
(defn with-bytes ^SegmState [^SegmState segm ^int id-delta
                             ^boolean clear-summaryv? ^bytes bs ^Class segm-cl]
  (let [bytesv' (when-some [bsv (.bytesv segm)]
                  (conj bsv bs))]
    (SegmState. (.env segm) (.ctx segm) (.source-file segm)
                (+ (.segm-id segm) id-delta) (segment-cld segm id-delta)
                (if clear-summaryv? [] (.summaryv segm)) bytesv'
                (or segm-cl (.prev-segment-class segm)))))

(defn- capstone-cld ^ClassDesc [^SegmState segm]
  (ClassDesc/of (-> segm .ctx .ns-str) ns-class-name))

(defn with-force-clinit ^ClassBuilder [^ClassBuilder cb]
  ;; static method with zero parameters, cannot clash with a
  ;; regular function's method name because of the suffix "~1";
  ;; FIXME... drop this and use requires~1 instead?
  (.withMethodBody cb rt/name-force-clinit rt/mtd-void-void
                   (bit-or Classfile/ACC_PUBLIC Classfile/ACC_STATIC
                           Classfile/ACC_FINAL)
                   (cf/with-xbh [xb] (.return_ xb))))

(defn- build-segment ^bytes [^SegmState segm ^boolean force-clinit?]
  (let [clinit-xb (cf/with-xbh [xb]
                    (let [ns-str (segment-ns-str segm)]
                      (when (= (.segm-id segm) first-segm-id)
                        (-> (.constantInstruction xb ns-str)
                            (cf/invoke rt/mhd-createNamespace)))
                      (doseq [^TlfSummary summary (.summaryv segm)]
                        (bytecode/emit-into xb (.top-level-form summary)))
                      (when (cfg/core-lib? ns-str)
                        (-> (.constantInstruction xb (segment-name segm 0))
                            (cf/invoke rt/mhd-markCoreInitialization))))
                    (.return_ xb))
        segm-cld (segment-cld segm 0)]
    (cf/build
     segm-cld
     (cf/with-cbh [cb]
       (when-not (= (.segm-id segm) first-segm-id)
         (.withSuperclass cb (segment-cld segm -1)))
       (doseq [^TlfSummary summary (.summaryv segm)]
         ;; emit fields and methods of all global bindings, delivering
         ;; their loads in order
         (doseq [^Binding global-b (.global-bs summary)]
           (bytecode/emit-global-b cb segm-cld global-b))
         (doseq [^FnSpec fspec (.fn-specs summary)]
           (.fn-methods (-> fspec .fn-form .!fnc .emit-plan) cb)))
       (-> (.withFlags cb Classfile/ACC_PUBLIC)
           (cf/with-source-file (.source-file segm))
           (cond-> force-clinit? (with-force-clinit))
           (.withMethodBody cf/class-initializer-name rt/mtd-void-void
                            (bit-or Classfile/ACC_PUBLIC Classfile/ACC_STATIC)
                            clinit-xb)))
     (segment-chr segm))))

(defn with-main ^ClassBuilder [^ClassBuilder cb ^SegmState segm]
  (letfn [(main-function ^BindingRef []
            (let [globals (.get-globals (.ctx segm))]
              (when-some [bref (get globals "-main" nil)]
                (when (some? (x/root-fn-form bref))
                  bref))))]
    (when-some [bref (main-function)]
      (let [main-mtd (MethodTypeDesc/of rt/void (.arrayType rt/String))
            flags (bit-or Classfile/ACC_PUBLIC Classfile/ACC_STATIC
                          Classfile/ACC_FINAL)
            xbh (cf/with-xbh [xb]
                  (let [mtd (MethodTypeDesc/of rt/object rt/IFn rt/object)]
                    (-> (cf/ld-insn xb (x/deref-load bref))
                        (.aload 0)
                        (.invokestatic rt/RT "apply" mtd)
                        (.pop)
                        (.return_))))]
        (.withMethodBody cb "main" main-mtd flags xbh)))))

(defn- build-capstone ^bytes [^SegmState segm ^Namespace nmsp]
  (let [requires-xb (cf/with-xbh [xb]
                      (let [s (if (nmsp/core-lib? nmsp)
                                "" ;suppress internal details of core lib
                                (str/join "," (sort (.req-strs nmsp))))]
                        (-> xb (.constantInstruction s) (.areturn))))]
    (cf/build
     (capstone-cld segm)
     (cf/with-cbh [cb]
       (-> (.withFlags cb Classfile/ACC_PUBLIC)
           (.withSuperclass (segment-cld segm -1))
           (cf/with-source-file (.source-file segm))
           (with-force-clinit)
           (.withMethodBody rt/name-requires rt/mtd-String-void
                            (bit-or Classfile/ACC_PUBLIC Classfile/ACC_STATIC
                                    Classfile/ACC_FINAL)
                            requires-xb)
           (with-main segm)))
     (segment-chr segm))))

(defn- build-class ^bytes [^ClassDef cdef ^String source-file ^CHR dyn-chr]
  (.register! dyn-chr (.ch-info cdef))
  (cf/build
   (-> cdef .ch-info .thisClass)
   (cf/with-cbh [cb]
     (-> (.withFlags cb (.flags cdef))
         (.withSuperclass (-> cdef .ch-info .superClass))
         (.withInterfaceSymbols (.itfs cdef))
         (cf/with-source-file source-file))
     (run! #(.accept ^Consumer % cb) (.cb-handlerv cdef)))
   dyn-chr))

(defn- build-deftype ^ClassDef [^DeftypeDef dtdef]
  (letfn [(method-cbh [^MethodDef mdef]
            (cf/with-cbh [cb]
              (let [at (.at mdef)
                    this-class (-> dtdef .cdef .ch-info .thisClass)
                    ld-this (cf/ld-st-receiver this-class
                                               (name (.this-name at)))
                    xbh (cf/with-xbh [xb]
                          (.deliver-load (.this-bref mdef) ld-this)
                          (cf/st-insn xb ld-this true) ;emit LocalVariable entry
                          (bytecode/emit-body xb ld-this at 0
                                              (.body-expr mdef)))]
                (.withMethodBody cb (.method-name at) (x/at-mtd at)
                                 (.flags mdef) xbh))))]
    (let [cdef (.cdef dtdef)]
      (cf/with-methods cdef (map method-cbh (.method-defs dtdef))))))

(defn- mk-first-segm ^SegmState [^BuildEnv env ^Ctx ctx ^boolean collect-bytesv?]
  (let [rurl (ctx/this-rurl ctx)
        source-file (when (and cfg/enable-line-numbers (some? rurl))
                      (let [s (.getPath rurl)]
                        (subs s (inc (.lastIndexOf s "/")))))
        cld (ClassDesc/of (.ns-str ctx)
                          (str ns-class-name first-segm-id))]
    (SegmState. env ctx source-file first-segm-id cld
                [] (when collect-bytesv? []) nil)))

(defn- emit-segments ^Namespace [^SegmState segm]
  (letfn [(all-fn-code [^SegmState segm]
            (->>  (.summaryv segm)
                  (mapcat #(.fn-specs ^TlfSummary %))
                  (map #(-> ^FnSpec % .fn-form .!fnc))))
          (write-fn-class ^SegmState [^SegmState segm ^FnCode fnc]
            (if-some [bs (.fn-class (.emit-plan fnc) (segment-chr segm))]
              (let [this ^ClassDesc (.ld-clx fnc)
                    cl (cfg/write-and-define-class (-> segm .env .dest-dir)
                                                   (segment-lookup segm)
                                                   this bs)]
                (with-bytes segm 0 false bs nil))
              segm))
          (write-segment ^SegmState [^SegmState segm ^boolean force-clinit?]
            (let [segm ^SegmState (reduce write-fn-class
                                          segm (all-fn-code segm))
                  bs (build-segment segm force-clinit?)
                  cl (cfg/write-and-define-class (-> segm .env .dest-dir)
                                                 (segment-lookup segm)
                                                 (segment-cld segm 0) bs)]
              (with-bytes segm +1 true bs cl)))
          (write-and-define ^SegmState [^SegmState segm ^ClassDef cdef
                                        ^CompletableFuture promise]
            (let [bs (build-class cdef (.source-file segm) (segment-chr segm))
                  this-class (-> cdef .ch-info .thisClass)
                  cl (cfg/write-and-define-class (-> segm .env .dest-dir)
                                                 (segment-lookup segm)
                                                 this-class bs)]
              (ctx/with-complete promise cl)
              (with-bytes segm 0 false bs nil)))
          (write-capstone ^Namespace [^SegmState segm ^Namespace nmsp]
            (let [bs (build-capstone segm nmsp)
                  cl (cfg/write-and-define-class
                      (-> segm .env .dest-dir)
                      (segment-lookup segm)
                      (capstone-cld segm) bs)
                  segm (with-bytes segm 0 true bs cl)]
              (nmsp/with-capstone nmsp cl (.bytesv segm))))
          
          (try-load-bref ^Object [^SegmState segm ^BindingRef bref]
            (when (.realized? bref)
              (let [global-mh (try
                                (let [l (-> segm .ctx .lookup-in-pkg)]
                                  (.mh-if-global (x/deref-load bref) l))
                                (catch ClassNotFoundException _
                                  nil))]
                (when (some? global-mh)
                  (if (nil? (.apply-mh (.ctx segm)))
                    ;; compiler and application share runtime?
                    ;; careful, this is a very brittle method type!
                    ^tinyclj.lang.StaticFnMh (.invokeExact global-mh)
                    (.invoke global-mh))))))
          (complete-req! ^SegmState [^SegmState segm ^int task x
                                     ^CompletableFuture promise]
            (condp = task
              ctx/req-macro-value
              ;; note: "flush class" requests are issued in arbitrary order
              ;; by namespace threads
              (let [bref ^BindingRef x]
                (if-some [f (try-load-bref segm bref)] ;first try
                  (do (.complete promise f)
                      segm)
                  (let [segm (write-segment segm false)] ;second and last try
                    (.complete promise (try-load-bref segm bref))
                    segm)))

              ctx/msg-emit-tlf
              (let [^TlfSummary summary x]
                (prepare/prepare-fns! (.segm-cld segm) (.source-file segm)
                                      (.fn-specs summary))
                (prepare/prepare-globals! (.segm-cld segm)
                                          (.global-bs summary))
                (let [segm (with-summary segm summary)
                      dyn-chr (segment-chr segm)]
                  (doseq [^FnCode fnc (all-fn-code segm)
                          :let [ep (.emit-plan fnc)]]
                    (when-some [ch-info (.fn-class-hierarchy-info ep)]
                      (.register! dyn-chr ch-info)))
                  segm))
              
              ctx/req-define-class
              (if (instance? ClassDef x)
                (write-and-define segm ^ClassDef x promise)
                (let [dtdef ^DeftypeDef x
                      summary (TlfSummary. (.fn-specs dtdef) nil x/expr-empty)]
                  (prepare/prepare-fns! (.segm-cld segm) (.source-file segm)
                                        (.fn-specs dtdef))
                  (-> (with-summary segm summary)
                      (write-and-define (build-deftype dtdef) promise))))
              
              ctx/req-define-class-ephemeral
              (let [cdef ^ClassDef x
                    bs (build-class cdef (.source-file segm) (segment-chr segm))
                    dyn-ld (-> (segment-lookup segm)
                               .lookupClass
                               (.getClassLoader))
                    ;; use a one shot class loader derived from `dyn-ld`
                    ld (cfg/class-loader-instance dyn-ld "tclj-eph" nil)
                    m (.getDeclaredMethod (class ld) "ephemeralClass"
                                          (.arrayType Byte/TYPE))]
                (ctx/with-complete promise
                  (.invoke m ld (doto (new objects 1) (aset 0 bs))))
                segm)

              ctx/req-flush-namespace-segment
              (let [segm (write-segment segm true)
                    force-x (x/invoke-force-clinit (.prev-segment-class segm))]
                (.complete promise force-x)
                segm)
              
              ctx/msg-fatal-error
              (throw ^Throwable x)
              
              #_else (throw (IllegalStateException. (str task)))))
          
          ;; Complete all requests with an exception, so that the
          ;; namespace thread does not run into a timeout.
          (drain-queue ^void [^BlockingQueue q ^Throwable t ^Msg msg]
            (when (ctx/needs-response? (.task msg))
              (.completeExceptionally ^CompletableFuture (.promise msg) t))
            (when-not (ctx/close-queue? msg)
              (recur q t (.take q))))]

    (let [msg ^Msg (-> segm .ctx .emit .q (.take))
          p (.promise msg)]
      (if (= (.task msg) ctx/msg-close-queue)
        (-> segm (write-segment false) (write-capstone (.x msg)))
        (-> (try
              (let [segm (complete-req! segm (.task msg) (.x msg) p)]
                (assert (or (nil? p) (.isDone p)))
                segm)
              (catch Throwable t
                (drain-queue (-> segm .ctx .emit .q) t msg)
                (throw t)))
            (recur))))))

(defn- preparer-thread [^EmitQueue emit ^HashSet !private-names]
  (letfn [(collect-fn-specs [acc ^MethodDef mdef]
            (let [body (.body-expr mdef)
                  summary (prepare/collect-fn-info !private-names body)]
              (into acc (.fn-specs summary))))]
    (let [msg ^Msg (.take (.s emit))]
      (condp = (.task msg)
        ctx/msg-emit-tlf
        (let [summary (prepare/collect-fn-info !private-names (.x msg))]
          (.put (.q emit) (Msg. (.task msg) summary (.promise msg))))

        ctx/req-define-class
        (condp instance? (.x msg)
          ClassDef
          (.put (.q emit) msg)
          
          DeftypeDef
          (let [dtdef ^DeftypeDef (.x msg)
                fn-specs (reduce collect-fn-specs [] (.method-defs dtdef))]
            (.put (.q emit) (Msg. (.task msg)
                                  (x/with-fn-specs dtdef fn-specs)
                                  (.promise msg))))

          #_else (throw (IllegalStateException.))) 
        
        ctx/req-flush-s-queue
        (.complete (.promise msg) nil)
        
        #_else (.put (.q emit) msg))
      
      (when-not (ctx/close-queue? msg)
        (recur emit !private-names)))))


(defn mk-provided-nmsp
  ([]
   (reduce-kv nmsp/assoc-provided {} predefined/implicit-known-ns))
  ([^String ns-str ^IPersistentMap publics]
   (nmsp/assoc-provided (mk-provided-nmsp) ns-str publics)))

(defn- init-known-ns ^void [^Ctx ctx ^IPersistentMap provided-nmsp]
  (doseq [[ns-str nmsp] provided-nmsp]
    (assert (string? ns-str))
    (assert (instance? Namespace nmsp)))
  (let [primitive-publics (-> (get provided-nmsp cfg/primitive-ns-str)
                              (nmsp/publics-of cfg/primitive-ns-str))]
    (doto ctx
      ;; primitive namespace can be used without require-ing it
      (.merge-into-known-ns {cfg/primitive-ns-str primitive-publics})
      (.put-ns-alias cfg/primitive-ns-str cfg/primitive-ns-str))))

;; Note: Exceptions are reported in the order in which they occur in
;; the emitter thread.  The "compile namespace" thread can fork of an
;; arbitrary number of futures of its own, and the emitter retrieves
;; their result/exception in emit order.
(defn- emit-namespace ^Namespace [^SegmState segm ^IPersistentMap provided-nmsp]
  (init-known-ns (.ctx segm) provided-nmsp)
  (cfg/prepare-class-directory (.dest-dir (.env segm))
                               (ctx/this-ns (.ctx segm)))
  (let [env (.env segm)
        ctx (.ctx segm)
        p-thread (ctx/start-solo-thread
                  ctx
                  (try
                    (preparer-thread (.emit ctx) (HashSet.))
                    (catch Throwable t ;no re-raise and wait for close-queue
                      (ctx/send-msg* (-> ctx .emit .q)
                                     ctx/msg-fatal-error t))
                    (finally          ;there is always a `close-queue`
                      (ctx/send-msg* (-> ctx .emit .q)
                                     ctx/msg-close-queue nil))))
        c-thread (ctx/start-solo-thread
                  ctx
                  (try
                    (let [nsd (nmsp/compile-thread env provided-nmsp ctx)]
                      ;; regular completion: pass back result in first
                      ;; `close-queue` message
                      (ctx/send-msg (.emit ctx) ctx/msg-close-queue nsd))
                    (catch Throwable t ;no re-raise and wait for close-queue
                      (ctx/send-msg (.emit ctx) ctx/msg-fatal-error t))
                    (finally          ;there is always a `close-queue`
                      (ctx/send-msg (.emit ctx) ctx/msg-close-queue nil))))
        nmsp (emit-segments segm)]
    (.join c-thread 5000l)      ;does not pick up result or exceptions
    (.join p-thread 5000l)      ;does not pick up result or exceptions
    nmsp))

(defn compile-and-emit ^Namespace [^BuildEnv env ^Ctx ctx
                                   ^boolean collect-bytesv?
                                   ^IPersistentMap provided-nmsp]
  (-> (mk-first-segm env ctx collect-bytesv?)
      (emit-namespace provided-nmsp)))

;;; ------------------------------------------------------------------------

(defn- try-load-capstone ^Class [^BuildEnv env ^String ns-str]
  (try
    (Class/forName (str ns-str "." ns-class-name) false (.dyn-ld env))
    (catch ClassNotFoundException _
      nil)))

(letfn [(extract-req-strs ^"[Ljava.lang.String;" [^Class cl]
          (let [s (-> (.getDeclaredMethod cl rt/name-requires)
                      ^String (.invoke nil))]
            (if (= s "")
              (new "[Ljava.lang.String;" 0)
              (into-array String (str/split s #",")))))]
  (defn- import-from-capstone ^Namespace [^Namespace nmsp ^Class capstone]
    (init-known-ns (.ctx nmsp) (.provided-nmsp nmsp))
    
    ;; keep in sync with namespace/add-require-deps
    (let [ns-str (.getPackageName capstone)
          req-strs (extract-req-strs capstone)
          n (count req-strs)
          a (new objects n)
          apublics (new "[Lclojure.lang.IPersistentMap;" n)
          provide-nmsp (.provided-nmsp nmsp)]
      ;; schedule namespaces in parallel
      (dotimes [i n]
        (let [req-str (aget req-strs i)]
          (aset a i (or (get (.provided-nmsp nmsp) req-str)
                        (-> (.require-namespace (.ctx nmsp))
                            (.schedule req-str provide-nmsp))))))
      ;; wait for and pick up namespace outcomes
      (dotimes [i n]                    ;avoid stack frame spamming
        (let [ns-str (aget req-strs i)]
          (aset apublics i (-> (nmsp/nmsp-of (aget a i) ns-str)
                               (nmsp/publics-of ns-str)))))
      ;; collect all "require"d globals and then add any new globals
      ;; to this namespace
      (loop [publics-map {}, i 0]
        (if (= i n)
          (.merge-into-known-ns (.ctx nmsp) publics-map)
          (let [ns-str (aget req-strs i)
                ekns (.exported-known-ns (nmsp/nmsp-of (aget a i) ns-str))]
            (recur (merge publics-map ekns) (inc i)))))
      (nmsp/with-capstone nmsp capstone nil))))

;;; ------------------------------------------------------------------------

(defn- get-apply-mh ^MethodHandle [^MethodHandles$Lookup l]
  (let [compiler-rt-witness tinyclj.lang.AFnMh
        app-rt-witness (.resolveConstantDesc rt/AFn l)
        shared-runtime? (identical? compiler-rt-witness app-rt-witness)]
    (if shared-runtime?
      nil
      (ctx/resolve-mh l rt/mhd-applyMacroMapped))))

(defn mk-ctx ^Ctx [^BuildEnv env
                   ^FnRequireNamespace require-namespace
                                 
                   ^IPersistentMap known-ns
                   ^IPersistentMap initial-globals
                   ^String ns-str
                                 
                   ^ExecutorService exc-method]
  (let [rpath (cfg/nmsp-rpath ns-str)
        rurl (or (.resolve-rpath env rpath)
                 (wrong/file rpath))
        ;; the namespace context needs a lookup into the package of
        ;; the namespace
        l (.rt-lookup env)
        lookup-in-pkg (beachhead/mk-lookup-in-pkg l (.dyn-ld env) ns-str)]
    (ctx/mk-ctx* initial-globals ns-str rpath rurl 
                 lookup-in-pkg require-namespace (get-apply-mh l) exc-method)))

(defn- emit-namespaces-mt ^IPersistentMap [^BuildEnv env ns-strs]
  (let [namespaces-q (java.util.concurrent.LinkedBlockingQueue.)
        !futs (ConcurrentHashMap.)]     ;updated by this thread only
    (ctx/with-executor namespaces-scope
      (letfn [(^FnRequireNamespace require-fn [ns-str provided-nmsp]
               (or
                ;; First peek into the current namespace map, and
                ;; return a known namespace immediately.
                (.get !futs ns-str)
                ;; For an unregistered namespace, delegate via message
                ;; exchange/promise to the top-level thread's
                ;; `namespace-loop`.
                (let [cf (CompletableFuture.)]
                  (.put namespaces-q [ns-str provided-nmsp cf])
                  (ctx/wait-for-result 1 cf))))
              
              (fork-namespace ^Future [^String ns-str provided-nmsp]
                (ctx/with-fork namespaces-scope
                  (or          ;import from dyn-ld or compile and emit
                   (when-some [cl (try-load-capstone env ns-str)]
                     (try
                       (-> (mk-ctx env require-fn {} {} ns-str nil)
                           (nmsp/mk-imported provided-nmsp)
                           (import-from-capstone cl))
                       (finally   ;signal completion to namespace loop
                         (.put namespaces-q [ns-str]))))
                   
                   (ctx/with-executor exc-method
                     (let [globals (predefined/initial-globals-for
                                    (.rt-lookup env) ns-str)
                           tl-ctx (mk-ctx env require-fn
                                          predefined/implicit-known-ns
                                          globals ns-str exc-method)]
                       #_(prn :namespace-start ns-str)
                       (ctx/with-context tl-ctx (some? namespaces-scope)
                         (try
                           (compile-and-emit env tl-ctx false provided-nmsp)
                           (finally ;signal completion to namespace loop
                             (.put namespaces-q [ns-str])))))))))
              
              (fork-all! ^int [ns-strs] ;returns number of new namespaces
                ;; this thread owns !futs and there are no concurrent
                ;; updates; using size() is ok, and test followed by
                ;; put as well
                (let [n (.size !futs)]
                  (doseq [ns-str ns-strs
                          :when (not (.containsKey !futs ns-str))
                          :let [fut (fork-namespace ns-str (.builtin-nmsp env))]]
                    (.put !futs ns-str fut))
                  (- (.size !futs) n)))]
        
        ;; In the first phase, force discovery of core library.  Only
        ;; after it has completed handle all namespaces from `ns-strs`
        ;; -- until the new namespaces have completed as well.
        (loop [n (fork-all! [cfg/core-lib])] ;`n` counts in-progress tasks
          (if (zero? n)              ;all pending tasks have completed
            (let [d (fork-all! ns-strs)] ;(re-)add all top-level namespace tasks
              (when (pos? d)     ;exit loop if no new tasks were added
                (recur d)))
            (let [[^String ns-str provided-nmsp ^CompletableFuture cf] (.take namespaces-q)]
              (if (some? cf)
                (if-some [fut (.get !futs ns-str)]
                  (do (.complete cf fut)
                      (recur n))
                  (let [fut (fork-namespace ns-str provided-nmsp)]
                    (.put !futs ns-str fut)
                    (.complete cf fut)
                    (recur (inc n))))
                (do #_(prn :namespace-end ns-str)
                    (recur (dec n)))))))))
    
    ;; If any namespace failed, then throw the first exception in
    ;; depth-first traversal order.  This should be deterministic,
    ;; even if there are errors in multiple namespaces and the
    ;; original exceptions are reported in arbitrary order.  It should
    ;; also report the same error in multi-threaded mode as in
    ;; single-threaded mode.
    (let [a ^"[Ljava.lang.String;" (into-array ns-strs)]
      ;; loop over array to avoid stack frame spamming
      (dotimes [i (alength a)]
        (ctx/get-result-now (.get !futs (aget a i))))) ;forces exception
    (into {} !futs)))

(defn- emit-namespaces-st ^IPersistentMap [^BuildEnv env ns-strs]
  (let [!futs (java.util.HashMap.)]     ;single-threaded!
    (letfn [(^FnRequireNamespace require-fn [ns-str provided-nmsp]
             (or (.get !futs ns-str)

                 (when-some [cl (try-load-capstone env ns-str)]
                   (.put !futs ns-str nmsp/marker-depth-first-path)
                   (let [x (-> (mk-ctx env require-fn {} {} ns-str nil)
                               (nmsp/mk-imported provided-nmsp)
                               (import-from-capstone cl))]
                     (.put !futs ns-str x)
                     x))
                 
                 (let [globals (predefined/initial-globals-for (.rt-lookup env)
                                                               ns-str)
                       tl-ctx (mk-ctx env require-fn
                                      predefined/implicit-known-ns
                                      globals ns-str nil)]
                   (ctx/with-context tl-ctx false
                     (.put !futs ns-str nmsp/marker-depth-first-path)
                     #_(prn :namespace-start ns-str)
                     (let [x (compile-and-emit env tl-ctx false provided-nmsp)]
                       #_(prn :namespace-end ns-str)
                       (.put !futs ns-str x)
                       x)))))]
      ;; first, force discovery of core library
      (.schedule require-fn cfg/core-lib (.builtin-nmsp env))
      ;; then handle all namespaces from `ns-strs`
      (let [a ^"[Ljava.lang.String;" (into-array ns-strs)]
        ;; loop over array to avoid stack frame spamming
        (dotimes [i (alength a)]
          (.schedule require-fn (aget a i) (.builtin-nmsp env))))
      (into {} !futs))))

(defn emit-namespaces ^IPersistentMap [^BuildEnv env ns-strs]
  (if cfg/deterministic-namespace-compile?
    (emit-namespaces-st env ns-strs)
    (emit-namespaces-mt env ns-strs)))

(defn summary ^IPersistentMap [^IPersistentMap ns-futs]
  (into {}
        (map (fn [^java.util.Map$Entry e]
               [(.getKey e) (ctx/get-result-now (.getValue e))]))
        ns-futs))

(defn success? ^boolean [^IPersistentMap ns-futs ns-strs]
  (letfn [(nmsp-exists? ^boolean [^String ns-str]
            (when-some [x (get ns-futs ns-str)]
              (not (instance? Throwable x))))]
    (every? nmsp-exists? ns-strs)))

