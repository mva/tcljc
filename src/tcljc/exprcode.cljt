(ns tcljc.exprcode
  (:require
   [tcljc.classfile :as cf]
   [tcljc.javabase :as jb]
   [tcljc.expr :as x]
   [tcljc.exprfold :as xf])
  (:import
   (tcljc.expr Expr Insn Const Progn Block Branch SplitJoin Switch
               LoopBody Recur TryCatchFinally Setter)
   (clojure.lang Symbol IPersistentVector))
  (:refer-clojure :exclude [type]))

;;; Special type of expressions that interrupt the normal flow of
;;; control: return, recur, throw.  This is a control flow indicator.
;;; Expressions that split/join control flow handle it specially.
;;; Parsing uses `void` instead of this type to produce the source
;;; Expr.
(deftype NoReturnMarker [])
(def ^:private no-return NoReturnMarker)
(defn- returning-type? ^boolean [^Class tp]
  (not (jb/same-class? no-return tp)))

(defn returns? ^boolean [^Expr x] ;excludes macro or primitive function values
  (returning-type? (x/type x)))


(definterface IAdaptResult
  (transform ^Expr [^Expr x]))          ;pre: (returns? x)

(def adpt-identity
  (reify IAdaptResult
    (transform [_ x]
      #_(assert (returns? x))
      x)))

(defn trace-flow ^Expr [^Expr x ^IAdaptResult adpt-res]
  (letfn [(trace-sequential ^Expr [^Expr x] ;pre: (>= (x/arg-count x) 2)
            (let [argv (x/argv x)
                  a (new "[Ltcljc.expr.Expr;" (count argv))
                  n-1 (dec (alength a))]
              (loop [i 0]
                (let [arg (nth argv i)]
                  (if (< i n-1)
                    (let [arg' (aset a i (trace-flow arg adpt-identity))]
                      (if (returns? arg')
                        (recur (inc i))
                        (x/with-argv x no-return (subvec (vec a) 0 (inc i)))))
                    (let [arg' (aset a i (trace-flow arg adpt-res))]
                      (x/with-argv x (x/type arg') (vec a))))))))
          (trace-instruction ^Expr [^Expr x ^IAdaptResult adpt-res]
            (let [argv (x/argv x)
                  a (new "[Ltcljc.expr.Expr;" (count argv))
                  n (alength a)]
              (loop [i 0]
                (if (< i n)
                  (let [arg' (aset a i (trace-flow (nth argv i) adpt-identity))]
                    (if (returns? arg')
                      (recur (inc i))
                      (Progn. (x/form x) no-return (subvec (vec a) 0 (inc i))
                              nil)))
                  (cond
                    (or (x/recur? x) (x/throw? x))
                    (x/with-argv x no-return (vec a))
                    (zero? (x/arg-count x))
                    (.transform adpt-res x)
                    :else
                    (.transform adpt-res (x/with-argv x (vec a))))))))
          (trace-paths ^"[Ltcljc.expr.Expr;" [^Expr x ^int dstart ^int dend
                                              ^IAdaptResult adpt-res]
            (let [argv (x/argv x)
                  a (new "[Ltcljc.expr.Expr;" (count argv))
                  end (+ (alength a) dend)]
              (loop [i dstart]
                (when (< i end)
                  (aset a i (trace-flow (nth argv i) adpt-res))
                  (recur (inc i))))
              a))
          (boolean-identities* ^Branch [^Branch b ^Expr left ^Expr right]
            ;; Folds boolean not, so that `not-primitive` can retain
            ;; the source code's operation.  Covers both identity and
            ;; not of boolean constant, independent of argument order.
            (cond
              (x/const-value? right)
              (if (x/branch? left)
                (-> (if (= (= cf/eq (.opcd b)) (x/const-value-false? right))
                      ;; either (== left false) or (not= left true)
                      (x/with-negate-cmp ^Branch left)
                      ;; either (not= left false) or (== left true)
                      ^Branch left)
                    (boolean-identities))
                b)

              (x/const-value? left)
              (recur b right left) ;no need to change `opcd`: it's eq or ne

              :else b))
          (boolean-identities ^Branch [^Branch b]
            (boolean-identities* b (x/nth-arg b 0) (x/nth-arg b 1)))
          (first-returning-type ^Class [[^Expr x :as xs]]
            ;; Type of first returning expression if one exists, and
            ;; no-return otherwise.
            (cond (nil? x) no-return
                  (returns? x) (x/type x)
                  :else (recur (next xs))))
          (reassemble-tcf ^Expr [^Expr x ^"[Ltcljc.expr.Expr;" a
                                 ^IAdaptResult adtp-res]
            (let [tp (if (returns? (aget a (dec (alength a))))
                       (first-returning-type (butlast a))
                       no-return)]
              (cond->> (x/with-argv x tp (vec a))
                (returning-type? tp)
                (.transform adtp-res))))
          (trace-branching ^Expr [^Expr x]
            (condp instance? x
              SplitJoin
              (let [branch (-> ^Branch (x/nth-arg x 0)
                               (boolean-identities)
                               (trace-instruction adpt-identity))]
                (if (returns? branch)
                  (let [a (doto (trace-paths x 1 0 adpt-res)
                            (aset 0 branch))]
                    (if (x/const-value? branch)
                      (aget a (if (x/const-value-true? branch) 1 2))
                      (x/with-argv x (first-returning-type (rest a)) (vec a))))
                  branch))
              Switch
              (let [test (trace-instruction (x/nth-arg x 0) adpt-identity)]
                (if (returns? test)
                  (let [a (doto (trace-paths x 1 0 adpt-res)
                            (aset 0 test))]
                    (x/with-argv x (first-returning-type (rest a)) (vec a)))
                  test))
              TryCatchFinally
              (let [n (x/arg-count x)
                    finally (trace-flow (peek (x/argv x)) adpt-identity)]
                (if (x/expr-empty? finally)
                  (let [a (doto (trace-paths x 0 -1 adpt-res)
                            (aset (dec n) finally))]
                    (if (= n 2)
                      (aget a 0)
                      (reassemble-tcf x a adpt-identity)))
                  (let [a (doto (trace-paths x 0 -1 adpt-identity)
                            (aset (dec n) finally))]
                    (reassemble-tcf x a adpt-res))))
              LoopBody
              (let [body (trace-flow (x/nth-arg x 0) adpt-res)]
                (x/with-argv x (x/type body) [body]))
              #_else
              (throw (IllegalArgumentException.))))]
    (if (x/strict-evaluation? x)
      (cond
        (x/sequential? x) (trace-sequential x)
        (x/branch? x) (trace-branching (x/split&join ^Branch x))
        :else (trace-instruction x adpt-res))
      (trace-branching x))))

(def ^:private adpt-return
  (reify IAdaptResult
    (transform [_ x]
      #_(assert (returns? x))
      (x/insn* no-return [x]
               (-> (cf/type-kind (x/type x))
                   (jdk.classfile.instruction.ReturnInstruction/of))))))

(defn as-returning-code ^Expr [^Expr x]
  (trace-flow x adpt-return))

