(ns tcljc.macro
  (:require [tcljc.wrong :as wrong])
  (:import (java.lang.invoke MethodHandle)
           (java.util.function Function)))

;;; In the "compiler bootstraps itself" scenario, a macro invocation
;;; is a huge problem.  The data that the compiler passes to the macro
;;; is not compatible with what the application's macro function
;;; expects.  The runtime classes are independent from each other, and
;;; e.g. a `clojure.lang.Symbol` instance of the compiler is different
;;; from an instance of the same class name on the application side.
;;; There are two `Symbol` classes owned by different class loaders,
;;; which means they live in separate worlds.
;;;
;;; The distance between the two representations is bridged by
;;; transport encodings based on standard JVM classes and interfaces.
;;; The two available transport encodings share the same container
;;; format, an array with a type tag, an element for meta information
;;; (possibly nil), and a data lement.  The special value `nil` is
;;; always mapped to null, and native JVM classes are mapped to
;;; themself.  These are the available representations:
;;;
;;; "Cpl" is the compiler side.  Data produced by the compiler's
;;; reader, data parsed by the compiler to generated bytecode.
;;;
;;; "App" is the application side.  Data that is passed to macro
;;; functions, and produced as the result of a macro invocation.
;;;
;;; "Array" serializes collection data into an array.
;;;
;;; "Itf" makes collection data availabe via an appropriate low-level
;;; Java interface it implements.

(def ^:private tag-seq (int 0))
(def ^:private tag-map (int 1))
(def ^:private tag-symbol (int 2))
(def ^:private tag-keyword (int 3))
(def ^:private tag-vector (int 4))
(def ^:private tag-set (int 5))

(defn- tagged-named ^objects [^int tag meta ^clojure.lang.Named t]
  (doto (new objects 4)
    (aset 0 (object tag))
    (aset 1 meta)
    (aset 2 (namespace t))
    (aset 3 (name t))))

(defn- tagged-coll ^objects [^int tag ^clojure.lang.IObj coll]
  (doto (new objects 3)
    (aset 0 (object tag))
    (aset 1 (meta coll))
    (aset 2 coll)))

;;; A function that maps "Cpl" data to "Itf" representation.
(deftype CplToItf [^ClassLoader shared-class-loader]
  java.util.function.Function
  (apply [_ t]
    (when (some? t)
      (cond
        (class? t)
        (throw (IllegalArgumentException.))
        (identical? shared-class-loader (.getClassLoader (.getClass t)))
        t
        (map? t)                        ;access via java.util.Map
        (tagged-coll tag-map t)
        (symbol? t)
        (tagged-named tag-symbol (meta t) t)
        (keyword? t)
        (tagged-named tag-keyword nil t)
        (vector? t)                     ;access via java.util.List
        (tagged-coll tag-vector t)
        (set? t)                        ;access via java.util.List
        (tagged-coll tag-set t)
        (seq? t)                        ;access via java.util.Iterable
        (tagged-coll tag-seq t)   ;discards meta of seq tails
        :else
        (throw (IllegalStateException. (str (.getClass t))))))))

(def ^:private cpl-to-itf (CplToItf. (.getClassLoader Object)))


(defn- add-meta [obj m]
  (if (identical? (meta obj) m)
    obj
    (with-meta obj m)))

;;; A function that maps "Array" data to "Cpl" representation.
(deftype ArrayToCpl [^ClassLoader shared-class-loader]
  Function
  (apply [_ t]
    (when (some? t)
      (cond
        (instance? objects t)
        (let [t ^objects t, tag (aget t 0), meta (aget t 1), data0 (aget t 2)]
          (-> (case ^int tag
                0 (let [data0 ^objects data0]
                    (if (zero? (alength data0))
                      ()
                      (clojure.lang.ArraySeq/create data0)))
                1 (clojure.lang.PersistentHashMap/create ^objects data0)
                2 (clojure.lang.Symbol/intern data0 (aget t 3))
                3 (clojure.lang.Keyword/intern data0 (aget t 3))
                4 (clojure.lang.LazilyPersistentVector/createOwning ^objects data0)
                5 (clojure.lang.PersistentHashSet/create ^objects data0)
                (throw (IllegalStateException. (str tag))))
              (add-meta meta)))
        
        (identical? shared-class-loader (.getClassLoader (.getClass t)))
        t
        
        :else (throw (IllegalStateException. (str (.getClass t))))))))

(def array-to-cpl (ArrayToCpl. (.getClassLoader Object)))


(defn apply-macro [^MethodHandle apply-mh f form env]
  (letfn [(wrong-arity [^Throwable cause]
            (throw (ex-info (str "wrong number of args (" (dec (count form))
                                 ") passed to macro") {} cause)))
          (wrong-expand [^Throwable cause]
            (throw (ex-info (str "error while expanding macro "
                                 (wrong/q (first form)))
                            {} cause)))

          ;; True if `x`'s class has the same name as `cl`.  Use this
          ;; if `x` may come from a different classloader, where class
          ;; identity checks or `instance?` may fail.  `x` may be nil.
          (classname? ^boolean [^Class cl ^Object x]
            (= (.getName cl) (some-> x (.getClass) (.getName))))]
    (assert (nil? env))
    (if (nil? apply-mh)
      (try
        (let [form ^clojure.lang.ISeq form]
          ;; mirrors steps in tinyclj.lang.RT/applyMacroMapped:
          (->> (.more form)
               (clojure.lang.Cons. env)
               (clojure.lang.Cons. form)
               (.applyTo ^tinyclj.lang.AFnMh f)))
        (catch clojure.lang.ArityException e
          (wrong-arity e))
        (catch Throwable t
          (wrong-expand t)))
      (try
        ;; Mapped macro invocation: translate the data
        ;; representation along the chain of Compiler -> JVM ->
        ;; Application/macro-expand -> JVM -> Compiler.
        (.invoke apply-mh cpl-to-itf array-to-cpl f form env)
        (catch Throwable t
          (if (classname? clojure.lang.ArityException t)
            (wrong-arity t)
            (wrong-expand t)))))))
