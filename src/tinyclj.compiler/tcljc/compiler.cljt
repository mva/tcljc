;; Copyright (c) Michael van Acken. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 2.0 (https://www.eclipse.org/legal/epl-v20.html)
;; which can be found in the file epl-v20.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.
(ns tcljc.compiler
  (:require
   [tcljc.classfile :as cf]
   [tcljc.util :as util]
   [tcljc.config :as cfg]
   [tcljc.javabase :as jb]
   [tcljc.runtime :as rt]
   [tcljc.io :as io]
   [tcljc.wrong :as wrong]
   [tcljc.reader :as rd]
   [tcljc.grammar :as grammar]
   [tcljc.context :as ctx]
   [tcljc.expr :as x]
   [tcljc.exprfold :as xf]
   [tcljc.type :as tp]
   [tcljc.compiler.sigfn :as sig]
   [tcljc.compiler.sigclass :as sigclass]
   [tcljc.compiler.conv :as conv]
   [tcljc.compiler.adapt :as adapt]
   [tcljc.compiler.resolve :as resolve]
   [tinyclj.string :as str])
  (:import
   (tcljc.context Ctx)
   (tcljc.classfile ClassDef)
   (tcljc.expr Expr InvokeXref Const Branch Guard TryHandler
               Binding BindingRef ValueRef MacroRef
               FnForm Arity ArityCode FnPatch
               PrimitiveFnRef FnPrimitiveFn FnMacroFn
               DeftypeDef MethodDef)
   (clojure.lang Symbol Var ISeq IPersistentVector IPersistentMap IMeta
                 ExceptionInfo)
   (java.lang.classfile ClassFile Opcode)
   (java.lang.constant ConstantDesc ClassDesc DirectMethodHandleDesc
                       ConstantDescs)
   (java.lang.reflect Constructor Method Field Executable)
   (java.util.concurrent Future BlockingQueue CompletableFuture)
   (java.util.function Consumer))
  (:refer-clojure :exclude [type]))     ;prevent use instead of x/type

(defn wrong-unresolved ^Expr [^Symbol sym]
  (wrong/unresolved "undefined symbol " sym))
(defn wrong-unresolved-nmsp ^Expr [^String ns-part ^Symbol sym]
  (wrong-unresolved (symbol ns-part "...")))

;;; If body raises an ExceptionInfo, then see if its `form` provides
;;; the best line number approximation of the error before re-raising
;;; it.  Primary use is around `compile-list` and `top-level-list`,
;;; but it should also be done for any syntactic list that the parser
;;; takes apart.
(defmacro with-error-context [[x-env form :as b] & body]
  (assert (vector? b))
  (assert (symbol? x-env))
  #_(assert (seq? form))
  `(let [~x-env (x/with-line-number ~x-env ~form)]
     (try
       ~@body
       (catch NoClassDefFoundError e#
         (wrong/rethrow-with-line-number (wrong/no-class-def-found e#)
                                         (x/x-ln ~x-env)))
       (catch clojure.lang.ExceptionInfo e#
         (wrong/rethrow-with-line-number e# (x/x-ln ~x-env))))))


(defn- assoc-fn-form ^ExceptionInfo [^ExceptionInfo e fn-form [op & args]]
  (let [data (-> (ex-data e)
                 (assoc :invoke/fn-form fn-form)
                 (assoc :invoke/arg-types (into-array Class (map x/type args))))]
    (ex-info (ex-message e) data (ex-cause e))))
(defn- wrong-no-arity [^FnForm fn-form [^Expr op & args]]
  (let [nm (when (instance? BindingRef op)
             (wrong/q (.simple-nm ^BindingRef op)))]
    (throw (wrong/mk-e (str "function " nm " has no arity " (count args))))))


(defn- take-member ^String [x]
  (if (symbol? x)
    (name x)
    (wrong/syntax "expect member name instead of" x)))

(defn- ensure-classname ^Class [^Expr x]
  (if-some [tp (x/classname-type x)]
    tp
    (x/wrong-type "expect class name" x))) ;wrong type or not constant

(defn- implements-ifn? ^boolean [^Expr x ^Ctx ctx]
  (.isAssignableFrom (ctx/get-type rt/clnm-ifn ctx) (x/type x)))
(defn- check-callable ^void [^Expr op-x ^Ctx ctx]
  (let [op-tp (x/type op-x)]
    (when-not (or (jb/same-class? jb/Object op-tp)
                  (jb/interface? op-tp)
                  (implements-ifn? op-x ctx))
      (x/wrong-type "called function's type does not implement `IFn`" op-x))))

(defn classname-expr ^Const [ssym ^Ctx ctx]
  (when (symbol? ssym)
    (when-some [tp (ctx/lookup-type ssym ctx)]
      (x/const jb/Class tp))))

(defn add-imports ^Expr [import-map ^Ctx ctx]
  (assert (identical? :import (:tag import-map)))
  (reduce (fn [res cl-nm]
            (if-some [x (classname-expr cl-nm ctx)]
              (let [cl (x/classname-type x)]
                (.put-import ctx (jb/import-symbol-short cl) cl)
                x)
              (sig/wrong-class cl-nm)))
          x/expr-empty (:classes import-map)))

;;; ------------------------------------------------------------------------

(defn- ensure-global ^Ctx [^Ctx ctx form]
  ;; Some forms, like non-assignment def, cannot work in a function, a
  ;; deftype* method, or a reify* method.
  (when-not (ctx/global? ctx)
    (wrong/other (str "cannot " (wrong/q (first form)) " in this position")
                 form))
  ctx)

(defn- compile-named ^Expr [^clojure.lang.Named nm ^Symbol tp-clnm ^Ctx ctx]
  (x/const (ctx/get-type tp-clnm ctx) nm))

(defn- compile-constant-nometa ^Expr [form ^Ctx ctx]
  (letfn [(const-desc-tp ^Class [form]
            (condp instance? form
              Integer jb/int
              Long jb/long
              Float jb/float
              Double jb/double
              String String
              #_else (throw (IllegalArgumentException.))))
          (number-tp ^Class [form]      ;pre: form is not ConstantDesc
            (condp instance? form
              Byte jb/byte
              Short jb/short
              #_else (throw (IllegalArgumentException.))))]
    (cond
      (nil? form) x/expr-nil-object
      (instance? ConstantDesc form) (x/const (const-desc-tp form) form)
      (keyword? form) (compile-named form rt/clnm-keyword ctx)
      (boolean? form) (x/expr-boolean ^boolean form) ;enforce singletons
      (char? form) (x/const jb/char (object (int ^char form)))
      (number? form) (x/const (number-tp form) (object (.intValue ^Number form)))
      :else (x/const (class form) form)))) ;Class and Pattern

(defn- with-meta-literal ^Expr [^Expr x ^Expr m]
  (let [tp (x/type x)]
    (if (and (x/const-value? x) (x/const-value? m))
      (x/const tp (with-meta (x/recover-primitive-const x)
                    (x/recover-primitive-const m)))
      (x/invoke-xref x/flags-no-ln tp [x m] nil rt/mhd-with-meta false))))

(defn- coll-literal ^Expr [^Class tp elems ^DirectMethodHandleDesc mhd]
  (if (every? x/const-value? elems)
    (let [cs (map x/recover-primitive-const elems)]
      (x/const tp (condp identical? mhd
                    rt/mhd-vector (vec cs)
                    rt/mhd-map (into {} (map vec) (partition 2 cs))
                    rt/mhd-set (set cs)
                    rt/mhd-list (or (list* cs) ())
                    (throw (IllegalArgumentException.)))))
    (x/mh-invoke-inexact x/flags-no-ln tp
                         (->> (map #(tp/coerce-vararg % jb/Object) elems)
                              (cons (x/const jb/MethodHandle mhd))) nil)))

(defn- compile-quote ^Expr [form ^Ctx ctx]
  (if (instance? IMeta form)
    (let [tp* (cond
                (symbol? form) 'symbol
                (seq? form) 'list
                (vector? form) 'vector
                (map? form) 'map
                (set? form) 'set
                :else (throw (IllegalArgumentException. (str (class form)))))]
      (x/const (ctx/get-type tp* ctx) form))
    (compile-constant-nometa form ctx)))


(defn var-type ^Class [^Ctx ctx]
  (ctx/get-type rt/clnm-Var ctx))

(defn- create-clj-var [^String nm-str ^Expr meta-x ^Expr init-x
                       ^boolean dynamic? ^Ctx ctx]
  (let [tp-Var (var-type ctx)]
    (letfn [(create-var ^Expr [^String nm-str ^Expr init-expr]
              (let [ldc-ns (x/const jb/String (ctx/this-ns ctx))
                    ldc-nm (x/const jb/String nm-str)]
                (if (some? init-expr)
                  (x/invoke-xref x/flags-no-ln tp-Var [ldc-ns ldc-nm init-expr]
                                 rt/mhd-var-3)
                  (x/invoke-xref x/flags-no-ln tp-Var [ldc-ns ldc-nm]
                                 rt/mhd-var-2))))
            (set-meta ^Expr [^Expr clj-var ^Expr meta]
              (x/invoke-xref x/flags-no-ln tp-Var [clj-var meta]
                             rt/mhd-Var-setMeta))
            (set-dynamic ^Expr [^Expr clj-var]
              (x/invoke-xref  x/flags-no-ln tp-Var [clj-var]
                              rt/mhd-Var-setDynamic))]
      (cond-> (create-var nm-str init-x)
        (some? meta-x) (set-meta meta-x)
        dynamic? (set-dynamic)))))

(deftype DelayedMacroFn [^tcljc.io.CompileIO compile-io
                         ^int defining-tlf-idx
                         ^BindingRef bref
                         ^CompletableFuture value-promise]
  FnMacroFn
  (expand [_ ctx form]
    (when (= defining-tlf-idx (.get-tlf-idx ^Ctx ctx))
      (wrong/other (str "cannot define and expand macro " (wrong/q (first form))
                        " in same top-level form")))
    (when-not (.isDone value-promise)
      (.send-to-emit compile-io io/msg-flush-macro-definitions nil))
    ;; pass nil as `env` for now
    (.apply-macro compile-io (.get value-promise) form nil)))

(defn def-form ^Expr [[_ nm :as form] ^Expr v ^BindingRef macro-v ^Ctx ctx]
  (letfn [(prior-def ^BindingRef [^Symbol nm]
            (when-some [bref (ctx/lookup-sname-global nm ctx)]
              (when (= (.ns-str bref) (ctx/this-ns ctx))
                bref)))
          (force-macro-to-class ^BindingRef [^BindingRef prior]
            (if (and (some? prior) (x/b-macro? prior))
              ;; make sure that the old definition has been defined
              ;; into some prior namespace segment, and treat the
              ;; redefinition as a fresh macro
              (.send-to-emit (.compile-io ctx)
                             io/msg-flush-macro-definitions nil)
              prior))
          
          (put-value-or-macro ^Binding [^String ns-str ^Symbol nm
                                        ^ValueRef bref ^Expr v]
            ;; For macros, there is a split view.  There is the
            ;; regular global binding that emits the bytecode for the
            ;; function, and the macro specific view on this binding
            ;; added to the symbol table.  Both include optional
            ;; "macro is used as a value" data, the former so that it
            ;; can be added to the bytecode as well, and the latter so
            ;; that it can be swapped in when the macro appears in
            ;; value position.
            (if (x/meta-flag? nm :macro)
              (let [bref (x/with-macro-value bref macro-v) ;then baked into mfn
                    mfn (DelayedMacroFn. (.compile-io ctx) (.get-tlf-idx ctx)
                                         bref (CompletableFuture.))
                    mref (x/macro-ref nm ns-str mfn macro-v bref)]
                (.send-to-emit (.compile-io ctx) io/msg-macro-of-next-tlf mfn)
                (ctx/put-global (name nm) mref ctx)
                (x/global-binding bref v))
              (do
                (ctx/put-global (name nm) bref ctx)
                (x/global-binding bref v))))
          (member-def-fresh ^Binding [^Symbol nm ^boolean redef?]
            ;; pre: non-var & non-alias & new member
            (let [dest-tag (sig/tag-of nm false jb/cl-polymorphic-type ctx)
                  v (conv/consume v dest-tag nm)
                  ns-str (ctx/this-ns ctx)
                  bref (x/global-ref nm ns-str (x/type v) redef? false v)]
              (put-value-or-macro ns-str nm bref v)))
          (assign-member-def-form ^Expr [^BindingRef bref ^Symbol nm]
            (when-not (x/b-mutable? bref)
              (wrong/other (str "prior definition of " (wrong/q nm)
                                " is final")))
            (let [v (conv/consume-for v bref)]
              (x/assign-def v bref)))
          (member-def-alias ^Expr [^Symbol nm ^BindingRef bref]
            (let [nm* (with-meta (x/qname bref) (meta nm))
                  aref (x/alias-ref x/lvl-global nm (ctx/this-ns ctx)
                                    bref x/b-def)]
              ;; global alias is just a new name for the old
              ;; BindingRef, without any additional work
              (ctx/put-global (name nm) aref ctx)
              ;; install a dummy field definition that allows to
              ;; reconstruct this alias when importing the namespace
              ;; from its class files
              (x/global-binding aref bref)))
          (member-def-noinit ^Expr [^Symbol nm]
            (let [redef? true           ;no init implies non-final
                  tp (sig/tag-of nm false jb/Object ctx)
                  bref (x/global-ref nm (ctx/this-ns ctx) tp redef? false nil)]
              (ctx/put-global (name nm) bref ctx)
              (x/global-binding bref nil)))
          (assign-var-def-form ^Expr [^BindingRef bref nm]
            (let [x (conv/consume-for v bref)
                  tp-Var (var-type ctx)
                  load-var (x/var-ref tp-Var bref)]
              (x/invoke-xref x/flags-no-ln jb/void [load-var v]
                             rt/mhd-Var-bindRoot)))
          (var-def-fresh ^Binding [nm form] ;new Clojure var
            (when (x/meta-flag? nm :macro)
              (wrong/other ":macro and :var are mutually exclusive"))
            (when (x/meta-flag? nm :redef)
              (wrong/other "FIXME ... :redef with :var"))
            (let [tp (sig/tag-of nm false jb/Object ctx)
                  x (create-clj-var (name nm)
                                    (when-some [meta (cfg/source-meta nm)]
                                      (compile-quote meta ctx))
                                    (when (some? v)
                                      (conv/consume v tp nm))
                                    (x/meta-flag? nm :dynamic)
                                    ctx)
                  bref (x/global-ref nm (ctx/this-ns ctx) tp false true x)]
              (ctx/put-global (name nm) bref ctx)
              (x/global-binding bref x)))
          (var-binding-then-get ^Expr [^Binding x]
            (let [tp-Var (var-type ctx)]
              (tp/prog2-expr x (x/var-ref tp-Var (.bref x)))))]
    
    (wrong/check-argc 1 2 form)
    (when (or (not (symbol? nm)) (some? (namespace nm)))
      (wrong/syntax "var name must be an unqualified symbol" nm))
    (if-some [d (-> (prior-def nm) (force-macro-to-class))]
      (do (assert (not (x/meta-flag? d :macro)) nm)
          (when-not (some? v)
            (wrong/other "redefinition must provide a value"))
          (if (x/meta-flag? d :var)
            (assign-var-def-form d nm)
            (assign-member-def-form d nm)))
      (do (ensure-global ctx form)
          (if (x/meta-flag? nm :var)
            (-> (var-def-fresh nm form)
                (var-binding-then-get))
            (do
              (when (x/meta-flag? nm :dynamic)
                (wrong/other (str "flag :dynamic requires flag :var for " (wrong/q nm))))
              (if (some? v)
                (let [redef? (x/meta-flag? nm :redef)]
                  (if (and (not redef?)
                           (x/pure-global-ref? v)
                           (not (x/b-private? ^BindingRef v)))
                    (member-def-alias nm ^BindingRef v)
                    (member-def-fresh nm redef?)))
                (member-def-noinit nm))))))))

;;; ------------------------------------------------------------------------

(deftype Env
    [^int level
     ;; Level assigned to bindings created in this environment.
     
     ^String mnm-path
     ;; Unique path string for this environment.  Nil if outside of
     ;; any fn* or reify*.
     
     ^IPersistentMap locals
     ;; Maps String to BindingRef.
     
     ^Object* !closes-over
     ;; Small mutable hash table recording the bindings that this
     ;; function closes over.  Will usually hold at most a handful of
     ;; entries, and is empty for most functions.  Entries can be
     ;; traversed in insertion order.
     
     ^Ctx ctx
     ;; The global context used by this environment.
     
     recur-fn
     ;; Nil if no recur possible.
     ])

(letfn [(assoc-bref ^IPersistentMap [^IPersistentMap acc ^BindingRef bref]
          #_(prn :assoc-bref (x/sname (bref)))
          (assoc acc (name (x/sname bref)) bref))
        (assoc-b ^IPersistentMap [^IPersistentMap acc ^Binding b]
          (assoc-bref acc (.bref b)))
        (with-locals ^Env [^Env env locals]
          (Env. (.level env) (.mnm-path env) locals (.!closes-over env)
                (.ctx env) (.recur-fn env)))]
  
  (defn add-local ^Env [^Env env ^Binding b]
    (with-locals env (assoc-b (.locals env) b)))
  (defn add-locals ^Env [^Env env bs]
    (with-locals env (reduce assoc-b (.locals env) bs)))
  (defn add-fields ^Env [^Env env brefs]
    (with-locals env (reduce assoc-bref (.locals env) brefs)))
  (defn- level-fn-form ^int [^Env env]
    (inc (.level env)))
  (defn- enter-fn-arity ^Env [^Env env ^String unique-mnm ^Arity at
                              ^ValueRef this-bref]
    (Env. (level-fn-form env) unique-mnm
          (cond-> (.locals env)
            (and (some? (.this-name at)) (some? this-bref))
            (assoc-bref this-bref))
          (.!closes-over at) (.ctx env) nil)))

(defn mk-recur-fn [bv]
  (fn recur-fn ^Expr [^Env env form args]
    (wrong/check-argc (count bv) form)
    (let [values (mapv (fn ^Expr [^Binding b ^Expr arg]
                         (conv/consume-for arg (.bref b)))
                       bv args)]
      (x/insn-recur jb/void values bv))))

(defn- resolve-sname-local ^BindingRef [^Env env ^Symbol sym]
  (when-some [x ^BindingRef (get (.locals env) (name sym))]
    (if (< x/lvl-global (x/b-level x) (.level env))
      (or (util/sim-get (.!closes-over env) x)
          (util/sim-put-absent! (.!closes-over env) x
                                (x/closure-alias (.level env) sym x)))
      x)))

(defn- resolve-sname-global ^Expr [^Symbol sym ^Ctx ctx]
  (or (ctx/lookup-sname-global sym ctx)
      (classname-expr sym ctx)))

(defn- resolve-qname-global ^Expr [^Symbol sym ^Ctx ctx]
  (ctx/lookup-qname-global sym ctx))

(defn- try-resolve-global ^Expr [^Symbol sym ^Ctx ctx]
  (if (namespace sym)
    (resolve-qname-global sym ctx)
    (resolve-sname-global sym ctx)))

(defn- ensure-resolve-global ^Expr [^Symbol sym ^Ctx ctx]
  (or (try-resolve-global sym ctx)
      (wrong-unresolved sym)))

(defn- expand-macro [^MacroRef x form ^Ctx ctx]
  ;; Note: Macro in an isolated runtime setup is much more expensive
  ;; than in the shared setup, where the compiler can call directly
  ;; into the macro function.
  (-> (.expand (.macro-fn x) ctx form)
      (cfg/with-line form)))

(defn- if-expr ^Expr [^Expr test ^Expr if-true ^Expr if-false]
  (let [test (tp/logical-value-of test)
        to-tp (x/type (conv/path-join if-true if-false))]
    (-> (if (x/branch? test)
          ;; If `test` is a branch instruction, then the new if just
          ;; adds the branches that complete it.
          ^Branch test
          (xf/icmp test x/expr-false cf/ne))
        (x/split&join to-tp if-true if-false (conv/adpt-for-path to-tp)))))

;;; Compile form with respect to the environment `env` and `x-env`.
;;; New Expr instances are assigned the line number `(x-ln x-env)`,
;;; which *must* be `form`'s line number if it is a seq.
;;; 
;;; Note: This function can produce a non-returning expression,
;;; including a reference to a macro or to a primitive function, but
;;; not an expression of type `jb/polymorphic?`.
(defn- compile-form* ^Expr [^Env env ^long x-env form]
  (letfn
      [(compile-io ^tcljc.io.CompileIO [^Env env]
         (-> env .ctx .compile-io))
       (compile-form ^Expr [^Env env ^long x-env form]
         (compile-form* env
                        (cond-> x-env (seq? form) (x/with-line-number form))
                        form))
       
       (with-recur-fn ^Env [^Env env recur-fn]
         (Env. (.level env) (.mnm-path env) (.locals env) (.!closes-over env)
               (.ctx env) recur-fn))
       (with-expr ^long [^long x-env]
         #_(-> x-env (x/without-recur) (x/without-inline-tcf))
         (x/x-ln x-env))                ;clear *all* flags
       (with-ctx ^Env [^Env env ^Ctx ctx]
         (Env. (.level env) (.mnm-path env) (.locals env) (.!closes-over env)
               ctx (.recur-fn env)))
       
       (expr-form ^Expr [form]    ;pre: `form` is not in tail position
         (-> (compile-form env (with-expr x-env) form)
             (x/ensure-runtime-value)
             (conv/consume-poly)))
       (expr-forms ^IPersistentVector [forms] ;returns vector of Expr
         ;; Not a mapv to keep stacktrace shallow & avoid closures.
         ;; Calls tend to short seqs.  Example element counts from
         ;; tcljc itself: 0 at ~14%, 1 at ~42%, 2 at ~28%, 3 at ~9%.
         (if-some [s (seq forms)]
           (loop [acc (vector (expr-form (first s))), s (next s)]
             (if (nil? s)
               acc
               (recur (conj acc (expr-form (first s))) (next s))))
           []))

       (tail-form ^Expr [form]
         (-> (compile-form env x-env form)
             (x/ensure-runtime-outcome)))
       (tail-forms ^Expr [^Env env ^long x-env forms]
         ;; Not a mapv to keep stacktrace shallow & avoid closures.
         ;; An empty `forms` is compiled to x/expr-empty.  For tcljc
         ;; itself, `forms` has exactly one element approximately 87%
         ;; of the time.  That is, the backedge of the loop is rarely
         ;; taken and plain `tail` returned instead.
         (if-some [forms (seq forms)]
           (loop [acc [], forms forms]
             (if-some [nxt (next forms)]
               (let [x (-> (compile-form env (x/without-recur x-env)
                                         (first forms))
                           (x/ensure-runtime-outcome))]
                 (recur (conj acc x) nxt))
               (let [tail (-> (compile-form env x-env (first forms))
                              (x/ensure-runtime-outcome))]
                 (tp/progn-expr acc tail))))
           x/expr-empty))
       
       (compile-body ^Expr [^Env env ^Arity at ^int body-idx]
         (-> (with-recur-fn env (mk-recur-fn (.paramv at)))
             (tail-forms (x/flags-body (.aform at))
                         (nthrest (.aform at) body-idx))
             (conv/consume-body (.rtype at) (if (some? (.method-name at))
                                              "method result"
                                              "arity result"))
             (x/loop-body)))
       (auto-rtype? ^boolean [^Arity at]
         (jb/polymorphic? (.rtype at)))
       (parse-arity-bodies ^FnForm [^FnForm fn-form ^Env env]
         ;; Parse all function arities in one future.  While the
         ;; smallest unit of work a single arity's body, there is
         ;; little use in moving each arity into a future of its own.
         (let [env' (with-ctx env (ctx/locked (.ctx env)))
               at-fn (^Callable fn []
                      (let [n (count (.at-sigs fn-form))
                            aca (new ArityCode* n)]
                        (dotimes [i n]
                          (let [at ^Arity (nth (.at-sigs fn-form) i)
                                this-bref (x/local-ref
                                           (.level fn-form) (.this-name at)
                                           (x/type fn-form) x/b-this-object
                                           fn-form)
                                unique-mnm (.unique-mnm fn-form)
                                body (with-error-context [x-env (.aform at)]
                                       (-> (enter-fn-arity env' unique-mnm
                                                           at this-bref)
                                           (add-locals (.paramv at))
                                           (compile-body at 1)))
                                at' (cond-> at
                                      (auto-rtype? at)
                                      (x/with-rtype (x/type body)))]
                            (aset aca i (x/mk-arity-code at' this-bref body))))
                        aca))
               body-fut (.fork-function (compile-io env) at-fn)
               fn-form (if (some auto-rtype? (.at-sigs fn-form))
                         ;; Must force future early to pick up the
                         ;; replacement type from the arity body.
                         (->> ^ArityCode*
                              (io/wait-for-result body-fut)
                              (mapv #(.at ^ArityCode %))
                              (x/with-at-sigs fn-form))
                         fn-form)]
           (x/with-body-fut fn-form body-fut)))

       (ensure-bindingv [x]
         (when-not (vector? x)
           (wrong/syntax "bindings must be a vector" x)))
       (take-binding-sym [[x :as xs]]
         (when (some? xs)
           (when-not (symbol? x)
             (wrong/syntax "expect binding name" x))
           (when (= (count xs) 1)
             (wrong/syntax "binding vector has odd number of elements"))
           x))
       (value-binding ^Binding [^Expr v ^int kind ^Symbol nm]
         (-> (x/local-ref (.level env) nm (x/type v) kind v)
             (x/local-binding v)))
       (bindings [^Env env bindings-vec ^int kind]
         (ensure-bindingv bindings-vec)
         (loop [env env
                bexprs []
                bs (seq bindings-vec)]
           (if-some [^Symbol nm (take-binding-sym bs)]
             (let [dest-tag (sig/tag-of nm false jb/cl-polymorphic-type (.ctx env))
                   v (compile-form env (x/without-recur x-env) (second bs))
                   b (if (and (not= kind x/b-loop)
                              (x/pure-let-initialization? v)
                              (jb/polymorphic? dest-tag))
                       ;; there is no type tag on `nm` and `v` could
                       ;; be a macro or primitive function
                       (let [v ^BindingRef v]
                         (-> (x/alias-ref (.level env) nm nil v x/b-let)
                             (x/local-binding v)))
                       (-> (x/ensure-runtime-value v)
                           (conv/consume dest-tag nm)
                           (value-binding kind nm)))]
               (recur (add-local env b) (conj bexprs b) (nnext bs)))
             [env bexprs])))
       (loop*-form ^Expr [[_ bindings-vec & body :as form]]
         (let [[^Env env bexprs] (bindings env bindings-vec x/b-loop)
               body (tail-forms (with-recur-fn env (mk-recur-fn bexprs))
                                (x/with-recur x-env)
                                body)]
           (x/block bexprs (x/loop-body body))))
       
       (recur-form ^Expr [form]
         (if (x/x-recur? x-env)
           ((.recur-fn env) env form (expr-forms (rest form)))
           (wrong/syntax "cannot recur from this position")))
       
       (if-form [[_ test if-true if-false :as form]]
         (wrong/check-argc 2 3 form)
         (let [expr-test (expr-form test)
               expr-true (tail-form if-true)
               expr-false (if (and (nil? if-false) (= (count form) 3))
                            (tp/default-value-of (x/type expr-true))
                            (tail-form if-false))]
           (if-expr expr-test expr-true expr-false)))

       (throw-no-match [^Expr e]
         (-> (x/invoke-xref x-env jb/Exception [(tp/reference-of e)]
                            rt/mhd-no-matching-clause)
             (x/throw)))
       (parse-case-clauses ^IPersistentVector [^Expr test clauses]
         (let [tp-test (condp identical? (x/type test)
                         jb/byte jb/int
                         jb/short jb/int
                         #_else (x/type test))]
           (loop [guardv []
                  path-idx 0
                  [g r :as clauses] (seq clauses)]
             (cond
               (nil? clauses)           ;case* has no default
               [guardv (throw-no-match test)]
               
               (nil? (next clauses))    ;case* ends with default
               [guardv (tail-form g)]

               :else
               (let [path-expr (tail-form r)]
                 (recur (into
                         guardv
                         (map #(do (-> (compile-quote % (.ctx env))
                                       (conv/consume tp-test "case expression"))
                                   (x/mk-guard path-idx path-expr %)))
                         (if (seq? g)
                           (do (when-not (seq g)
                                 (wrong/other "empty list of test constants"))
                               g)
                           [g]))
                        (inc path-idx)
                        (nnext clauses)))))))
       (guard-path-idx ^int [^Guard g]
         (.path-idx g))
       (clause-code-segment [gs]
         (let [xs (map (fn [^Guard g] (.gvalue g)) gs)]
           (-> (if (= (count xs) 1) (first xs) xs)
               (compile-quote (.ctx env)))))
       (clause-code-expr ^Expr [^Expr e guardv]
         (let [cexprv (->> (partition-by guard-path-idx guardv)
                           (mapv clause-code-segment))]
           (x/invoke-dynamic x-env jb/int
                             [(x/identity jb/Object (tp/reference-of e))]
                             rt/bsm-clause-code cexprv)))
       (case*-form [[_ expr & clauses :as form]]
         ;; Note: The test expression is evaluated again if a
         ;; synthetic throw is added as default path.  That means that
         ;; the wrapping macro should pass in a let binding as `expr`.
         (wrong/check-argc-min 1 form)
         (let [test (expr-form expr)
               [guardv ^Expr dflt-path] (parse-case-clauses test clauses)
               all-pathv (conj (x/guard-paths guardv) dflt-path)
               to-tp (x/type (conv/path-join all-pathv))
               guardv (mapv (fn ^Guard [^Guard g]
                              (x/with-path-expr g
                                (nth all-pathv (.path-idx g))))
                            guardv)]
           ;; check for duplicate values in guards
           (->> (map #(.gvalue ^Guard %) guardv)
                (reduce (fn [seen x]
                          (when (contains? seen x)
                            (wrong/other (str "duplicate test constant: "
                                              (wrong/q x))))
                          (conj seen x))
                        #{}))
           (if (.computational-int? (tp/of-expr test)) ;switch over int
             (x/switch to-tp test dflt-path (mapv x/with-guard-int-value guardv)
                       (conv/adpt-for-path to-tp))
             ;; else: hashmap lookup followed by switch over encoder index
             (x/switch to-tp (clause-code-expr test guardv) dflt-path
                       (->> (partition-by guard-path-idx guardv)
                            (mapv #(x/with-guard-path-idx (first %))))
                       (conv/adpt-for-path to-tp)))))
       
       (let*-form ^Expr [[_ bindings-vec & body :as form]]
         (let [[env bexprs] (bindings env bindings-vec x/b-let)]
           (x/block bexprs (tail-forms env x-env body))))
       
       (ensure-distinct-fn-names [fnv]
         (doseq [x fnv]
           (when-not (seq? x)
             (wrong/syntax "function binding must be a list" x))
           (wrong/ensure-simple-sym (first x)))
         (when-not (apply distinct? nil (map first fnv))
           (wrong/other (str "duplicate names in letfn bindings: "
                             (->> (map first fnv)
                                  (frequencies)
                                  (remove #(= (val %) (object 1)))
                                  (map (comp str key))
                                  (str/join " "))))))
       (macroexpand-fnvec [fnv]
         (letfn [(prefix-with-fn [x]    ;prefix, discarding inner meta
                   (cons 'fn (with-meta x nil)))
                 (expand-once [[op-sym :as form]] ;pre: `form` is `seq?`
                   ;; internal error if `op-sym` in not a symbol referring to
                   ;; a macro; this code follows the logic of `compile-list`
                   (let [x (ensure-resolve-global op-sym (.ctx env))
                         m ^MacroRef (x/root-bref ^BindingRef x)]
                     (expand-macro m form (.ctx env))))
                 (expand-fn [form]
                   (let [ex (expand-once form)]
                     (if (and (seq? ex) (= (first ex) 'fn*))
                       ex
                       (do (assert (not (identical? form ex))
                                   "cyclic macro expansion in letfn*")
                           (recur ex)))))
                 (destructure-to-fn* [form]
                   (with-meta (expand-fn (prefix-with-fn form))
                     (meta form)))]
           (ensure-bindingv fnv)
           (ensure-distinct-fn-names fnv)
           (into [] (map destructure-to-fn*) fnv)))
       (invoke-patch-fn ^Expr [^Binding b]
         (FnPatch. x-env jb/void [] nil ^FnForm (x/first-arg b) (.bref b)))
       (letfn*-form [[_ fnv & body :as form]]
         (let [fn-formv (mapv (fn ^FnForm [form]
                                (let [level (level-fn-form env)
                                      mnm (.pick-unique-mnm (compile-io env)
                                                            (.mnm-path env) 'fn
                                                            form)]
                                  (with-error-context [x-env form]
                                    (sig/destructure-fn*-form form level mnm (.ctx env)))))
                              (macroexpand-fnvec fnv))
               bexprv (mapv (fn [^FnForm fn-form]
                              (value-binding fn-form x/b-let
                                             (x/fn-this-name fn-form)))
                            fn-formv)
               env (add-locals env bexprv)
               bexprv (mapv (fn ^Binding [^Binding b]
                              (let [fn-form ^FnForm (x/first-arg b)
                                    fn-form' (parse-arity-bodies fn-form env)]
                                (x/local-binding (.bref b) fn-form')))
                            bexprv)
               body (tp/progn-expr (mapv invoke-patch-fn bexprv)
                                   (tail-forms env x-env body))]
           (x/block bexprv body)))
       
       (do-form ^Expr [[_ & exprs :as form]]
         (tail-forms env x-env (rest form)))

       (fn*-form ^FnForm [form]
         (let [level (level-fn-form env)
               unique-mnm (.pick-unique-mnm (compile-io env)
                                            (.mnm-path env) nil form)
               fn-form (sig/destructure-fn*-form form level unique-mnm (.ctx env))]
           (parse-arity-bodies fn-form env)))
       
       (quote-form ^Expr [form]
         (wrong/check-argc 1 form)
         (compile-quote (second form) (.ctx env)))

       (var-form [[_ arg :as form]]
         (wrong/check-argc 1 form)
         (let [arg (wrong/ensure-sym arg)
               v ^BindingRef (ensure-resolve-global arg (.ctx env))]
           (when (not (x/b-def-var? v))
             (wrong/other (str (wrong/q arg) " is not a ^:var def")))
           (x/var-ref (var-type (.ctx env)) v)))
       
       (import*-form ^Expr [form] ;returns the value of the last class
         (let [import-map (grammar/parse-import-specs (rest form))]
           (add-imports import-map (.ctx env))))
       
       (dot-form* ^Expr [^long x-env ^Expr cl-or-inst ^String nm arg-forms]
         (let [argv (expr-forms arg-forms)]
           (if-some [owner (x/classname-type cl-or-inst)]
             (resolve/invoke-as-static x-env owner nm argv)
             (resolve/invoke-as-virtual x-env cl-or-inst nm argv))))
       (dot-form ^Expr [[_ owner member-or-list & xr :as form]]
         (wrong/check-argc-min 2 form)
         (let [cl-or-inst (expr-form owner)]
           (if (seq? member-or-list)
             (with-error-context [x-env member-or-list]
               (wrong/check-argc 2 form)
               (dot-form* x-env cl-or-inst (take-member (first member-or-list))
                          (next member-or-list)))
             (dot-form* x-env cl-or-inst (take-member member-or-list) xr))))

       (settable-deftype-field? ^boolean [^Expr x]
         (if (x/bref? x)
           (let [bref ^BindingRef x]
             (and (x/b-mutable? bref) (= (x/b-level bref) x/lvl-environment)))
           false))
       (settable-var? ^boolean [^Expr x]
         (and (x/bref? x) (x/b-def-var? ^BindingRef x)))
       (set!-form [[_ v x :as form]]
         (wrong/check-argc 2 form)
         (let [v-expr (expr-form v)
               tp (x/type v-expr)
               x-expr (conv/consume (expr-form x) tp v)]
           (cond
             (or (x/settable-getter? v-expr) (settable-deftype-field? v-expr))
             (x/setter tp v-expr x-expr (x/invoke-xref-static? v-expr))
             
             (settable-var? v-expr)
             (let [v-expr (x/var-ref (var-type (.ctx env)) ^BindingRef v-expr)]
               (-> (x/invoke-xref x-env jb/Object [v-expr x-expr] rt/mhd-Var-set)
                   (xf/checkcast tp)))
             
             :else
             (wrong/other (str "not a settable variable: " (wrong/q v))))))

       (parse-method ^ArityCode [^Env env ^Arity at ^Class etp]
         ;; based on `parse-arity-bodies` above
         (with-error-context [x-env (.aform at)]
           (let [receiver-b (sig/mk-receiver (.level at) (.this-name at) etp)
                 env (add-locals env (cons receiver-b (.paramv at)))]
             (x/mk-arity-code at (.bref receiver-b)
                              (compile-body env at 2)))))
       (method-def ^MethodDef [^Env env form ^Class etp]
         (with-error-context [x-env form]
           (let [at (sigclass/method-arity-type etp form x/lvl-environment
                                                -1 (.ctx env))
                 ac (parse-method env at etp)]
             (MethodDef. (.at ac) ClassFile/ACC_PUBLIC
                         (.this-bref ac) (.body-expr ac)))))
       (create-ephemeral-class ^Class [^ClassDef cdef]
         (let [bs (cf/build
                   (.this-class cdef)
                   (cf/with-cbh [cb]
                     (-> (cf/with-version cb)
                         (.withFlags (.flags cdef))
                         (.withSuperclass (cf/super-class cdef))
                         (.withInterfaceSymbols (.itfs cdef)))
                     (run! #(.accept ^Consumer % cb) (.cb-handlerv cdef))))
               dyn-ld (ctx/dyn-ld (.ctx env))
               ;; use a one shot class loader derived from `dyn-ld`
               ld (cfg/class-loader-instance dyn-ld "tclj-eph" nil)
               m (.getDeclaredMethod (class ld) "ephemeralClass"
                                     (.arrayType Byte/TYPE))]
           (-> (.invoke m ld (doto (new Object* 1) (aset 0 bs)))
               (cfg/validate-defined-class))))
       (dtp-class-def ^DeftypeDef [^Env env short-sym fq-sym binary-sym
                                   field-sig opts methods]
         (let [ctx (.ctx env)
               this-class (ClassDesc/of (name binary-sym))
               cdef (sigclass/eph-dtp-class-def (ctx/this-ns ctx)
                                                (.get-imports ctx)
                                                this-class field-sig opts
                                                methods ctx)
               
               ;; Construct ephemeral type instance that is only valid
               ;; inside this deftype* and derive the deftype's
               ;; compilation context from it.
               etp (create-ephemeral-class cdef)
               method-ctx (ctx/locked-in-class ctx etp)
           
               ;; Moving method compilation to other threads does not help
               ;; much, because compilation can only progress once this
               ;; class has been defined.
               field-brefs (sigclass/dtp-field-brefs this-class field-sig
                                                     method-ctx)
               env (add-fields env field-brefs)
               method-env (with-ctx env method-ctx)
               mdefs (mapv #(method-def method-env % etp) methods)]
           (DeftypeDef. cdef field-brefs mdefs)))
       (deftype*-form ^Expr [[_ fq-sym binary-sym field-sig
                              & opts+specs :as form]]
         ;; only do rudimentary error messages because this form is
         ;; produced by a macro
         (assert (vector? field-sig))
         (ensure-global (.ctx env) form)
         (let [short-sym (symbol nil (name fq-sym))
               [opts methods] (loop [acc {}, [x :as xs] opts+specs]
                                (if (keyword? x)
                                  (recur (assoc acc x (second xs)) (nnext xs))
                                  [acc xs]))
               cdef (dtp-class-def env short-sym fq-sym binary-sym
                                   field-sig opts methods)
               cl (.send-to-emit (compile-io env) io/req-define-class cdef)]
           ;; only continue once the class has been defined
           x/expr-empty))

       (reify*-form ^Expr [[_ itf-vector & methods :as form]]
         (when-not (vector? itf-vector)
           (wrong/syntax "expect vector of interface classes" itf-vector))

         ;; reify* shares the general "closing over values" mechanism
         ;; with functions.  For this reason, it is implemented as
         ;; part of the function framework.  There are a number of
         ;; differences, though.  Super type of reify* is Object
         ;; (instead of AFnMh).  A reify* instance cannot be invoked
         ;; like a function.  reify* always implements IObj, on top of
         ;; the interfaces given in its definition.  A reify* instance
         ;; is never translated into a constant (the assumption being
         ;; that it always closes over some non-trivial value).
         ;; reify* stores its own meta, and its value is passed to its
         ;; static factory method (while functions always start with a
         ;; meta of `nil`).
         (let [unique-mnm (.pick-unique-mnm (compile-io env)
                                            (.mnm-path env) 'reify form)
               ctx (.ctx env)
               this-class (ClassDesc/of (ctx/this-ns ctx) unique-mnm)
               eph-cdef (sigclass/eph-reify-class-def this-class itf-vector ctx)
               
               etp (create-ephemeral-class eph-cdef)
               
               atv (reduce (fn [acc form]
                             (with-error-context [x-env form]
                               (let [at-idx (count acc)
                                     level (level-fn-form env)
                                     at (sigclass/method-arity-type
                                         etp form level at-idx ctx)]
                                 (conj acc at))))
                           [] methods)
               m (compile-meta (cfg/source-meta form))

               ;; A reify's ephemeral type is leaked into expression
               ;; trees.  It becomes visible for example when invoking
               ;; a method on the receiver.
               env' (with-ctx env (ctx/locked ctx))
               m-fn (^Callable fn []
                     (let [
                           n (count atv)
                           aca (new ArityCode* n)]
                       (dotimes [i n]
                         (let [at ^Arity (nth atv i)]
                           (aset aca i (-> (enter-fn-arity env' unique-mnm
                                                           at nil)
                                           (parse-method at etp)))))
                       aca))
               body-fut (.fork-function (compile-io env) m-fn)]
           (-> (x/fn-form-reify form etp m (level-fn-form env) unique-mnm
                                (.super-mhd eph-cdef) atv)
               (x/with-body-fut body-fut))))
       
       (definterface*-form [form]
         (let [ctx (ensure-global (.ctx env) form)
               cdef (sigclass/itf-class-def (ctx/this-ns ctx) (.get-imports ctx) form)
               cl (.send-to-emit (.compile-io ctx) io/req-define-class cdef)]
           x/expr-empty))

       (catch-form? ^boolean [x]
         (and (seq? x) (= (first x) 'catch)))
       (finally-form? ^boolean [x]
         (and (seq? x) (= (first x) 'finally)))
       (body-form? ^boolean [x]
         (not (or (catch-form? x) (finally-form? x))))
       (split-body-catches-finally [xs]
         (let [[body xs] (split-with body-form? xs)
               [cs xs] (split-with catch-form? xs)
               [fs xs] (split-with finally-form? xs)]
           (when-not (<= (count fs) 1)
             (wrong/syntax "multiple finally clauses in try form"))
           (when (seq xs)
             (wrong/syntax "junk at end of try form"))
           [body cs (first fs)]))
       (catch-form [^Env env [_ class-expr nm & body :as form]]
         (let [class-x (expr-form class-expr)
               tp (ensure-classname class-x)
               _ (when-not (symbol? nm)
                   (wrong/syntax "expect binding name" nm))
               _ (when-not (jb/throwable? tp)
                   (x/wrong-type "expect subclass of Throwable" class-x tp))
               ;; the exception instance is similar to a parameter
               ;; (externally provided and not locally computed) but
               ;; must be taken from the stack first; the binding's
               ;; init expression is expr-provided representing the
               ;; "out of thin air" character
               bref (x/local-ref (.level env) nm tp x/b-let)
               b (x/local-binding bref (x/expr-provided tp))]
           [tp (-> (x/block [b] (tail-forms (add-local env b)
                                            (-> (x/without-recur x-env)
                                                (x/with-line-number form))
                                            body)))]))
       (try-form* ^Expr [[_ & forms :as form]]
         (let [[body cs f] (split-body-catches-finally forms)
               body-expr (tail-forms env (-> (x/without-recur x-env)
                                             (x/with-line-number form))
                                     body)
               ecs (mapv #(catch-form env %) cs) ;eager
               finally-statm (-> (tail-forms env (-> (with-expr x-env)
                                                     (x/with-line-number f))
                                             (rest f))
                                 (tp/coerce-to-void))]
           (let [all-paths (cons body-expr (map second ecs))
                 to-tp (x/type (conv/path-join all-paths))]
             (x/try-catch-finally to-tp body-expr
                                  (mapv (fn [[catch-ex _] catch-body]
                                          (x/try-handler catch-ex catch-body))
                                        ecs (rest all-paths))
                                  finally-statm
                                  (conv/adpt-for-path to-tp)))))
       (try-form ^Expr [form]
         (if (x/x-inline-tcf? x-env)
           (try-form* form)
           (-> (list (list 'fn* 'try (with-meta [] {:tag 'auto-return-type})
                           form))
               (cfg/with-line form)
               (expr-form))))

       (throw-form ^Expr [[_ arg :as form]]
         (wrong/check-argc 1 form)
         (let [arg (expr-form arg)]
           (when-not (jb/throwable? (x/type arg))
             (x/wrong-type "expect instance of Throwable" arg))
           (x/throw arg)))
       
       (monitor-form ^Expr [^Opcode opc [_ arg :as form]]
         (wrong/check-argc 1 form)
         (let [lockee (expr-form arg)]
           (when-not (x/reference? lockee)
             (x/wrong-type "monitor operation requires a reference" lockee))
           (x/insn* x-env jb/void [lockee]
                    (java.lang.classfile.instruction.MonitorInstruction/of opc))))

       (class-const-or-expr ^Expr [form]
         (-> (if (symbol? form)
               (or (when (nil? (namespace form))
                     (classname-expr form (.ctx env)))
                   (expr-form form))
               (expr-form form))
             (conv/consume jb/Class "type expression")))
       (new-form ^Expr [[_ cl-arg & args :as form]]
         (wrong/check-argc-min 1 form)
         (let [cn-expr (class-const-or-expr cl-arg)
               argv (expr-forms args)
               tp (x/classname-type cn-expr)]
           (cond
             (nil? tp)                  ;implied by `cn-expr` of nil
             (wrong/syntax "classname must be symbol or string" cl-arg)
             
             (jb/array? tp)
             (let [lengthv (mapv #(adapt/checked adapt/numeric-to-int %) argv)
                   an (cfg/array-dims tp)]
               (if (<= 1 (count lengthv) an)
                 (x/new-array x-env tp lengthv)
                 (wrong/other (str (if (= an 1)
                                     "expect one dimension length"
                                     (str "expect 1 to " an " dimension lengths"))
                                   (wrong/got-int (count argv))))))
             :else
             (resolve/invoke-as-constructor x-env tp argv))))
       
       (instanceof*-form ^Expr [[_ cl-arg arg :as form]]
         (wrong/check-argc 2 form)
         (let [cn-expr (class-const-or-expr cl-arg)
               arg (expr-form arg)]
           (if-some [tp (x/classname-type cn-expr)]
             (do
               (when (jb/primitive? tp)
                 (x/wrong-type (str "expect class, array, or interface type")
                               cl-arg tp))
               (when (jb/primitive? (x/type arg))
                 (x/wrong-type "expect argument of reference type" arg))
               (x/type-check arg Opcode/INSTANCEOF tp))
             (do
               (when (jb/primitive? (x/type arg))
                 (x/wrong-type "expect argument of reference type" arg))
               (x/invoke-xref x-env jb/boolean [cn-expr arg] rt/mhd-isInstance)))))

       
       (adapt-args [op+argv ^Arity at ^int vararg-start ^Class vararg-tp]
         (loop [acc op+argv, i 1]
           (if (< i (count op+argv))
             (let [arg (nth op+argv i)]
               (recur
                (if (>= i vararg-start)
                  ;; FIXME... After Valhalla, revise this to adapt
                  ;; vararg arguments to parameter type as well?
                  (assoc acc (object i) (-> (conv/consume-poly arg)
                                            (tp/coerce-vararg vararg-tp)))
                  (let [bref (x/at-nth-bref at (dec i)), param-tp (x/type bref)]
                    (if (or (jb/same-class? param-tp (x/type arg))
                            (and (jb/object? param-tp) (x/reference? arg)))
                      ;; fast path: assume that acc isn't modified
                      ;; most of the time
                      acc
                      (assoc acc (object i) (conv/consume-for arg bref)))))
                (inc i)))
             acc)))
       (call-fn-def ^Expr [^FnForm fn-form op+argv]
         (try
           (let [n (dec (count op+argv))
                 at (x/fn-at fn-form n)]
             (when (nil? at)
               (wrong-no-arity fn-form op+argv))
             (let [rt (.rtype at)]
               (when (jb/compile-time-entity? rt)
                 (wrong/other "calling function arity with unknown result type"))
               (let [argv (if-some [vararg-tp (x/at-extern-vararg-type at)]
                            (-> (adapt-args op+argv at (x/at-n at) vararg-tp)
                                (x/fix-vararg-array at))
                            (adapt-args op+argv at Integer/MAX_VALUE jb/Object))]
                 (x/invoke-arity x-env rt argv fn-form (.at-idx at)))))
           (catch clojure.lang.ExceptionInfo e
             (throw (assoc-fn-form e fn-form op+argv))
             nil)))
       (call-fn-expr ^Expr [^Expr op-x form]
         (let [op+argv (into [(x/ensure-runtime-value op-x)]
                             (expr-forms (rest form)))]
           (if-some [fn-form (x/callable-root-fn-form op-x)]
             (call-fn-def fn-form op+argv)
             (do (check-callable op-x (.ctx env))
                 (x/invoke-fn x-env jb/cl-polymorphic-type
                              (-> (mapv conv/consume-poly op+argv)
                                  (x/fix-vararg-array)))))))
       
       (compile-meta ^Expr [m]
         (if (nil? m)
           x/expr-nil-object
           ;; Problem: Cannot evaluate the `foo` in a meta map like
           ;; {:tag foo}.  E.g. `int` would refer to a primitive
           ;; function and does not have a value, while `objects` only
           ;; exists as a class shortcut and not as a global var.
           ;; Solution: Quote the value of the :tag map entry to
           ;; retain its Symbol (or String) value.
           (compile-atom (if-some [[k v] (find m :tag)]
                           (assoc m k (list cfg/sym-quote v))
                           m))))
       (collection-form ^Expr [^Symbol tp-clnm elems ^DirectMethodHandleDesc mhd]
         (coll-literal (ctx/get-type tp-clnm (.ctx env))
                       (map conv/consume-poly (expr-forms elems)) mhd))
       (resolve-static-member ^Expr [^Symbol sym] ;pre: (some? (namespace sym))
         (let [ns-part (namespace sym)]
           (if-some [tp (ctx/get-type (symbol nil ns-part) (.ctx env))]
             (resolve/invoke-as-static x-env tp (name sym) [])
             (wrong-unresolved-nmsp ns-part sym))))
       (compile-atom ^Expr [form]
         (if (instance? IMeta form)
           (-> (cond
                 (symbol? form) ;close to 90% hit rate for "is a symbol"
                 (if (namespace form)
                   (or (resolve-qname-global form (.ctx env))
                       (resolve-static-member form)
                       (wrong-unresolved form))
                   (or (resolve-sname-local env form)
                       (resolve-sname-global form (.ctx env))
                       (wrong-unresolved form)))
                 
                 (var? form) ;can come out of macro expansion, like Class
                 (compile-list (list 'var (.toSymbol ^Var form)))
                 
                 :else
                 (let [x (cond
                           (vector? form)
                           (collection-form rt/clnm-vector (seq form)
                                            rt/mhd-vector)
                           (map? form)
                           (collection-form rt/clnm-map (mapcat identity form)
                                            rt/mhd-map)
                           (set? form)
                           (collection-form rt/clnm-set (seq form)
                                            rt/mhd-set)
                           (seq? form)
                           (collection-form rt/clnm-list form
                                            rt/mhd-list)
                           :else
                           (throw (IllegalStateException. (str (class form)))))]
                   (if-some [m (cfg/source-meta form)]
                     (with-meta-literal x (compile-meta m))
                     x)))
               (maybe-type-hint form))
           (compile-constant-nometa form (.ctx env))))

       (compile-macro-value ^BindingRef [nm]
         (when (symbol? nm)
           (when (x/meta-flag? nm :macro)
             (when-some [mv-form (get (meta nm) :macro-value)]
               (let [mv-form (wrong/ensure-sym mv-form)]
                 (-> (or (if (namespace mv-form)
                           (resolve-qname-global mv-form (.ctx env))
                           (resolve-sname-global mv-form (.ctx env)))
                         (wrong-unresolved mv-form))
                     ^BindingRef (x/ensure-runtime-value)))))))
       (init-value-of-def ^Expr [form]  ;nil if init is not specified
         (when-some [xs (nthnext form 2)]
           ;; accepts anything, including macros or primitive functions
           (compile-form env (x/without-recur x-env)
                         (-> (first xs) (cfg/with-line form)))))
       (compile-list-special ^Expr [^Symbol op-form form] ;nil if regular
         (when (nil? (namespace op-form))
           (case op-form
             def (let [v (init-value-of-def form)
                       macro-v (compile-macro-value (second form))]
                   (def-form form v macro-v (.ctx env)))
             loop* (loop*-form form)
             recur (recur-form form)
             if (if-form form)
             case* (case*-form form)
             let* (let*-form form)
             letfn* (letfn*-form form)
             do (do-form form)
             fn* (fn*-form form)
             quote (quote-form form)
             var (var-form form)
             import* (import*-form form)
             . (dot-form form)
             set! (set!-form form)
             deftype* (deftype*-form form)
             reify* (reify*-form form)
             try (try-form form) ;note: finally & catch are not specials
             throw (throw-form form)
             monitor-enter (monitor-form Opcode/MONITORENTER form)
             monitor-exit (monitor-form Opcode/MONITOREXIT form)
             ;; catch is only special within `try-form`
             ;; finally is only special within `try-form`
             new (new-form form)
             ;; & is only special within arity signature

             ;; special forms that are not special in Clojure:
             definterface* (definterface*-form form)
             instanceof* (instanceof*-form form)
             #_else nil)))
       (starts-with-dot? ^boolean [^String s]
         (and (= (.charAt s 0) \.) (> (.length s) 1)))
       (ends-with-dot? ^boolean [^String s]
         (let [len (.length s)]
           (and (= (.charAt s (- len 1)) \.)
                (>= len 2) (not (= (.charAt s (- len 2)) \.)))))
       (compile-dotted-symbol ^Expr [^Symbol x [_ inst & formr :as form]]
         ;; Returns nil on mismatch.
         (let [nm (name x)]
           (cond
             (starts-with-dot? nm)
             (if (= nm "..")
               (do (wrong/check-argc-min 2 form)
                   (dot-form (reduce (fn [form member]
                                       (list '. form member))
                                     inst formr)))
               (do (wrong/check-argc-min 1 form)
                   (resolve/invoke-as-virtual x-env (expr-form inst)
                                              (subs nm 1) (expr-forms formr))))
             
             (and (nil? (namespace x)) (ends-with-dot? nm))
             (new-form (list* 'new (symbol nil (subs nm 0 (dec (count nm))))
                              (rest form)))

             :else nil)))
       (compile-static-dot-form ^Expr [^Symbol op-form form]
         ;; pre: (some? (namespace op-form))
         ;; post: never returns nil
         (let [ns-part (namespace op-form)]
           (if-some [x (classname-expr (symbol nil ns-part) (.ctx env))]
             (dot-form (list* '. (.const-value x) (symbol nil (name op-form))
                              (rest form)))
             (wrong-unresolved-nmsp ns-part op-form))))
       (compile-list ^Expr [^ISeq form]
         (let [op-form (first form)]
           (if (symbol? op-form)
             (or (compile-list-special op-form form)
                 (compile-dotted-symbol op-form form)
                 (let [x (if (nil? (namespace op-form))
                           (or (resolve-sname-local env op-form)
                               (resolve-sname-global op-form (.ctx env))
                               (wrong-unresolved op-form))
                           (or (resolve-qname-global op-form (.ctx env))
                               (compile-static-dot-form op-form form)))]
                   (cond
                     (or (x/invoke-xref? x) (x/invoke-poly? x))
                     x                  ;dot form (Foo/bar ...)
                     
                     (and (x/bref? x) (x/b-primitive? x))
                     (let [p ^PrimitiveFnRef (x/root-bref x)]
                       (.assemble (.primitive-fn p) form
                                  (expr-forms (rest form))
                                  x-env (compile-io env)))
                     
                     (and (x/bref? x) (x/b-macro? x))
                     (let [m ^MacroRef (x/root-bref x)]
                       ;; compile macro with line number of this list form
                       (compile-form env x-env (expand-macro m form (.ctx env))))
                     
                     :else
                     (call-fn-expr x form))))

             (if (seq form)             ;guard against empty list
               (-> (compile-form env (x/without-recur x-env) op-form)
                   (call-fn-expr form))
               (compile-atom form))))) ;empty list (), possibly with meta
       
       (maybe-type-hint ^Expr [^Expr x ^IMeta form]
         (let [tag (sig/tag-of form true nil (.ctx env))]
           (cond
             (jb/polymorphic? (x/type x))
             (-> (x/ensure-runtime-value x)
                 (x/with-monomorphic-result (or tag jb/Object)))

             (some? tag)
             (let [x (x/ensure-runtime-value x)]
               (cond
                 (x/type? tag x) x
                 
                 (jb/primitive? tag)
                 (cond
                   (jb/void? tag) (tp/coerce-to-void x)
                   (x/reference? x) (tp/unbox-to (tp/of tag) x)
                   :else (x/wrong-type (str "cannot cast to " (wrong/q tag)) x))

                 (x/primitive? x)
                 (x/wrong-type (str "cannot cast to " (wrong/q tag)) x)
                 
                 :else (tp/coerce x tag)))

             :else x)))]             ;`x` can be a compile-time entity
    
      #_(binding [*print-meta* #_false true]
          (prn :compile-form form)
          #_(when (seq? form) (prn :classes (map class form))))
      (-> (if (seq? form)
            (with-error-context [x-env form]
              (maybe-type-hint (compile-list form) form))
            (compile-atom form)))))

(defn top-level-form ^void [form ^Ctx ctx]
  (let [env (Env. x/lvl-environment nil {} nil ctx nil)
        x (-> (compile-form* env (x/flags-top-level-form form) form)
              (x/ensure-runtime-outcome)
              (conv/consume jb/void "top-level form"))]
    (.send-to-emit (.compile-io ctx) io/msg-emit-tlf x)
    (.increment-tlf-idx ctx)))

;;; ------------------------------------------------------------------------

(def list-primitive
  (^FnPrimitiveFn fn [form argv x-env compile-io]
   ;; mirrors `collection-form`, with `args` being Exprs already
   (let [tp (.resolveConstantDesc rt/list (.lookup-in-pkg compile-io))]
     (coll-literal tp argv rt/mhd-list))))

(defn- as-anonymous-bindings [args]
  ;; note: simplified version of logic from fn bindings above
  (loop [bexprs []
         brefs []
         [init-with & argr] args]
    (if (nil? init-with)
      [bexprs brefs]
      (if (x/pure-let-initialization? init-with)
        (recur bexprs (conj brefs init-with) argr)
        (let [nm '__temp
              bref (x/local-ref -1 nm (x/type init-with) x/b-let init-with)
              b (x/local-binding bref init-with)]
          (recur (conj bexprs b) (conj brefs bref) argr))))))

(defn nary-cmp ^FnPrimitiveFn [^FnPrimitiveFn binary-pfn]
  (^FnPrimitiveFn fn [form args x-env compile-io]
   (wrong/check-argc-min 1 form)
   (case (bounded-count 3 args)
     1 (tp/prog2-expr (nth args 0) x/expr-true)
     2 (.assemble binary-pfn form args x-env compile-io)
     ;; Compute all arguments beforehand, otherwise the short circuit
     ;; logic of `if` may skip their exceptions.  Expand as primitive
     ;; instead of macro, because a macro would depend on gensym.
     (let [[bexprs brefs] (as-anonymous-bindings args)
           res (reduce (fn [cont [ref1 ref2]]
                         (let [test (.assemble binary-pfn nil [ref1 ref2]
                                               x-env compile-io)]
                           (if-expr test cont x/expr-false)))
                       x/expr-true
                       (reverse (partition 2 1 brefs)))]
       (x/block bexprs res)))))

(letfn [(resolve-mref ^MacroRef [op ^Ctx ctx]
          (when (and (symbol? op) (not (contains? cfg/specials op)))
            (when-some [x (try-resolve-global op ctx)]
              (let [bref (x/root-bref ^BindingRef x)]
                (when (instance? MacroRef bref)
                  ^MacroRef bref)))))
        (macroexpand-once [form ^Ctx ctx]
          (if (seq? form)
            (if-some [mref (resolve-mref (first form) ctx)]
              (expand-macro mref form ctx)
              form)
            form))
        (unquote-arg [arg]
          (if (and (seq? arg) (= (count arg) 2) (= (first arg) cfg/sym-quote))
            (second arg)
            (wrong/other "expect quoted form as argument")))]
  ;; Half-assed macroexpansion is done by a predefined macro, not a
  ;; regular function.  As such the argument must be a quoted
  ;; expression (with the quoted argument being the expansion input),
  ;; and by symmetry the result is a quote of the expanded form.  The
  ;; returned quote is then evaluated in the usual way, producing the
  ;; expanded form as a runtime value.
  
  (def macroexpand-1-form
    (^FnMacroFn fn [ctx form]
     (wrong/check-argc 1 form)
     (list cfg/sym-quote (macroexpand-once (unquote-arg (second form)) ctx))))

  (def macroexpand-form
    (^FnMacroFn fn [ctx form]
     (wrong/check-argc 1 form)
     (loop [form (unquote-arg (second form))]
       (let [ex (macroexpand-once form ctx)]
         (if (identical? ex form)
           (list cfg/sym-quote form)
           (recur ex)))))))

(def read-string-form
  (^FnMacroFn fn [ctx [_ arg :as form]]
   (wrong/check-argc 1 form)
   (if (string? arg)
     (let [rd (rd/mk-reader arg)
           x (.read-1 rd ctx ::EOF)]
       (if (= x ::EOF)
         (wrong/other "EOF while reading")
         (list cfg/sym-quote x)))
     (wrong/other "argument of read-string must be a string literal"))))
