;; Copyright (c) Michael van Acken. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 2.0 (https://www.eclipse.org/legal/epl-v20.html)
;; which can be found in the file epl-v20.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.
(ns tcljc.compiler.branch
  (:require [tcljc.classfile :as cf]
            [tcljc.javabase :as jb]
            [tcljc.runtime :as rt]
            [tcljc.wrong :as emap]
            [tcljc.expr :as x]
            [tcljc.exprfold :as xf]
            [tcljc.compiler.conv :as conv])
  (:import (tcljc.expr Expr Branch)
           (java.lang.classfile Opcode)))

;;; Cast any computational int expression (including char and boolean)
;;; to an integer value.
(defn cast-to-int ^Expr [^Expr x]       ;pre: `x` is computational int
  (x/identity jb/int x))

(defn conv-to-boolean ^Expr [^Expr x]
  (cond
    (x/boolean? x)                   ;primitive boolean
    x

    (x/primitive? x)             ;only void and no-return are false
    (xf/prog2-expr x (x/expr-boolean (x/pushes-result? x))) 

    (and (not (x/const-value? x)) (.isAssignableFrom (x/type x) Boolean))
    (x/invoke-xref jb/boolean [x] rt/mhd-truthy-reference)

    :else       ;any reference that is a non-Boolean subtype of Object
    (xf/acmp x x/expr-nil-object cf/ne)))

(defn if-expr ^Expr [^Expr test ^Expr if-true ^Expr if-false]
  (let [test (conv-to-boolean test)
        to-tp (x/type (conv/path-join if-true if-false))]
    (-> (if (x/branch? test)
          ;; If `test` is a branch instruction, then the new if just
          ;; adds the branches that complete it.
          ^Branch test
          (xf/icmp test x/expr-false cf/ne))
        (x/split&join to-tp if-true if-false (conv/adpt-for-path to-tp)))))

;;; ------------------------------------------------------------------------

(defn xcmp ^Expr [^int cmp-opcd ^Expr arg0 ^Expr arg1]
  (let [arg0 (conv/ensure-numeric arg0)
        arg1 (conv/ensure-numeric arg1)
        to-cl (conv/upper-numeric-tp arg0 arg1)]
    (if (jb/same-class? Integer/TYPE to-cl)
      (xf/icmp arg0 arg1 cmp-opcd)
      (letfn [(nan-opcode ^Opcode [^Opcode g ^Opcode l]
                (case cmp-opcd (#_lt 2 #_le 5) g #_else l))]
        (-> (xf/xcmp-signum (conv/widen-from to-cl arg0)
                            (conv/widen-from to-cl arg1)
                            (condp jb/same-class? to-cl
                              Double/TYPE (nan-opcode Opcode/DCMPG Opcode/DCMPL)
                              Float/TYPE (nan-opcode Opcode/FCMPG Opcode/FCMPL)
                              #_else Opcode/LCMP))
            (xf/icmp x/expr-zero-int cmp-opcd))))))
