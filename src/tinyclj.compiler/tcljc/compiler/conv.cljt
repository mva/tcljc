;; Copyright (c) Michael van Acken. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 2.0 (https://www.eclipse.org/legal/epl-v20.html)
;; which can be found in the file epl-v20.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.
(ns tcljc.compiler.conv
  (:require
   [tcljc.javabase :as jb]
   [tcljc.runtime :as rt]
   [tcljc.wrong :as wrong]
   [tcljc.expr :as x]
   [tcljc.exprfold :as xf]
   [tcljc.type :as tp])
  (:import
   (tcljc.expr Expr BindingRef IAdaptPath)))

(def ^:private show-class-loader false)

(letfn [(class-loader-suffix [tp]
          (when show-class-loader
            (if (class? tp)
              (if-some [ld (.getClassLoader ^Class tp)]
                (or (.getName ld) "not-named")
                nil #_"bootstrap")
              "class-desc")))]
  (defn type-str ^String [clx]
    (str (.displayName (rt/cd-of clx)) (class-loader-suffix clx))))

;;; ------------------------------------------------------------------------

(defn- jvm-adapt-to ^Expr [^Class to-tp ^Expr from] ;returns nil on failure
  (let [from-tp (x/type from)]
    (cond
      (or (jb/same-class? to-tp from-tp) (jb/polymorphic? to-tp))
      ;; cheapest: `from` matches `to-tp` and can be used as is
      from

      (or (jb/jvm-assignable-to? from-tp to-tp)
          (jb/void? to-tp)
          (and (jb/reference? to-tp) (x/pushes-nil-object? from)))
      (tp/coerce from to-tp)

      :else (let [to (tp/of to-tp)]
              (cond
                (tp/widens-to-numeric? (tp/of from-tp) to)
                (.adapt (.primitive-to to) from)

                (tp/unboxes-to? from-tp to)
                (tp/checkcast-and-unbox-to to from)
          
                :else nil)))))

(letfn [(checked-assign ^Expr [^Expr from ^Class to-tp dest-descr]
          (let [from-tp (x/type from)]
            (or (jvm-adapt-to to-tp from)

                (when (jb/void? from-tp)
                  (tp/prog2-expr from (tp/default-value-of to-tp)))
        
                (when (jb/jvm-assignable-to? to-tp from-tp)
                  (tp/coerce from to-tp))

                (x/wrong-type (str "cannot assign to " (wrong/q to-tp)
                                   (when (some? dest-descr)
                                     (str " of " (wrong/q-symbol dest-descr))))
                              from))))]
  
  ;; Transform `x` into a type that can be represented as a non-void
  ;; type descriptor.  In particular, void is turned into an expression that
  ;; pushes a nil operand of type Object.
  ;; 
  ;; pre: `x` is a runtime value & not polymorphic.
  (defn consume-poly ^Expr [^Expr x]
    (let [x-tp (x/type x)]
      (if (jb/void? x-tp)
        (tp/prog2-expr x x/expr-nil-object)
        x)))

  ;; Transform `x` into a type that is assignment compatible to type
  ;; `to-tp`.  If `to-tp` is jb/polymorphic?, this function delegates
  ;; to `consume-poly`.
  ;; 
  ;; pre: `x` is a runtime value & not polymorphic.
  (defn consume ^Expr [^Expr x ^Class to-tp dest-descr]
    (if (jb/polymorphic? to-tp)
      (consume-poly x)
      (checked-assign x to-tp dest-descr)))
  (defn consume-for ^Expr [^Expr x ^BindingRef bref]
    ;; FIXME... `simple-nm` is nil for imported parameters because
    ;; reflection does not offer this information
    (consume x (x/type bref) (.simple-nm bref)))

  ;; Special case of `consume` which passes on an expression `x` if
  ;; `to-tp` is polymorphic.
  (defn consume-body ^Expr [^Expr x ^Class to-tp ^String to-result]
    (if (jb/polymorphic? to-tp)
      x
      (checked-assign x to-tp to-result))))

;;; ------------------------------------------------------------------------

(def ^:private expr-some-object (x/const jb/Object "expr-some-object"))
(defn path-join
  (^Expr [xs]
   (reduce path-join (first xs) (rest xs)))
  (^Expr [^Expr x0 ^Expr x1]
   (letfn [(path-adaptable ^Expr [^Expr to ^Expr from]
             ;; Return `to` if `from` can be adapted to `to`, and nil
             ;; otherwise.
             (let [to-tp (x/type to), from-tp (x/type from)]
               (when (or (jb/void? from-tp)
                         (tp/adaptable-to? from-tp to-tp)
                         (and (jb/reference? to-tp)
                              (x/pushes-nil-object? from)))
                 to)))]
     (or (when (x/same-type? x0 x1) x0)
         (path-adaptable x0 x1)
         (path-adaptable x1 x0)
         (when (and (x/reference? x0) (x/reference? x1))
           expr-some-object)       ;must differ from x/expr-nil-object
         (wrong/other (str "incompatible path types " (wrong/str* (x/type x0))
                           " and " (wrong/str* (x/type x1))))))))

(deftype AdaptForPath [^Class to-tp]
  IAdaptPath
  (apply-to-instr [_ x]
    (or (jvm-adapt-to to-tp x)
        (cond       ;non-Java type conversions are possible for paths!
          (x/void? x)
          (tp/prog2-expr x (tp/default-value-of to-tp))
        
          (and (jb/same-class? jb/int to-tp) (x/character? x))
          ;; rejected by language, but ok for emitted code
          (.adapt (.primitive-to tp/int) x)
        
          :else
          (throw (IllegalStateException.
                  (str "to " to-tp " <- x " (x/type x)))))))
  (after [this before]
    (if (and (instance? AdaptForPath before)
             (.isAssignableFrom to-tp (.to-tp ^AdaptForPath before)))
      this
      (x/adpt-comp this before)))
  (safe-instructions? [_]
    true)
  (toString [_]
    (str "afp-" (.getName to-tp))))
(def adpt-for-path ->AdaptForPath)
