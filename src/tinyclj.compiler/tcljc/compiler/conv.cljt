;; Copyright (c) Michael van Acken. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 2.0 (https://www.eclipse.org/legal/epl-v20.html)
;; which can be found in the file epl-v20.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.
(ns tcljc.compiler.conv
  (:require
   [tcljc.javabase :as jb]
   [tcljc.runtime :as rt]
   [tcljc.wrong :as wrong]
   [tcljc.expr :as x]
   [tcljc.exprfold :as xf]
   [tcljc.type :as tp])
  (:import
   (tcljc.expr Expr BindingRef IAdaptPath)))

;; pre: (not (or (jb/polymorphic? ptype) (jb/void? ptype)))
(defn consume-argument ^Expr [^Expr x ^Class ptype dest-descr]
  (if-some [tc (tp/argument-conversion (x/type x) ptype)]
    (.adapt tc x)
    (x/wrong-type (str "cannot assign to " (wrong/q ptype)
                       (when (some? dest-descr)
                         (str " of " (wrong/q-symbol dest-descr))))
                  x)))

;; Transform `x` into a type that can be represented as a non-void
;; type descriptor.  Type `void` is turned into an expression that
;; pushes a nil operand of type Object, and all other expressions are
;; passed unchanged.
;; 
;; pre: `x` is a runtime value & not polymorphic.
(defn consume-for-descriptor ^Expr [^Expr x]
  (let [x-tp (x/type x)]
    (if (jb/void? x-tp)
      (tp/prog2-expr x x/expr-nil-object)
      x)))

;; Transform `x` into a value whose type is `to-tp`.  If `to-tp` is
;; jb/polymorphic?, this function delegates to
;; `consume-for-descriptor`.
;; 
;; pre: `x` is a runtime value & not polymorphic.
(defn consume ^Expr [^Expr x ^Class to-tp dest-descr]
  (cond
    (jb/void? to-tp) (tp/coerce-to-void x)
    (jb/polymorphic? to-tp) (consume-for-descriptor x)
    :else (let [x' (consume-argument x to-tp dest-descr)]
            (if (x/type? to-tp x')
              x'
              (x/identity to-tp x')))))
(defn consume-for ^Expr [^Expr x ^BindingRef bref]
  ;; FIXME... `simple-nm` is nil for imported parameters because
  ;; reflection does not offer this information
  (consume x (x/type bref) (.simple-nm bref)))

;;; ------------------------------------------------------------------------

(def ^:private expr-some-object (x/const jb/Object "expr-some-object"))
(defn path-join
  (^Expr [xs]
   (reduce path-join (first xs) (rest xs)))
  (^Expr [^Expr x0 ^Expr x1]
   (letfn [(path-adaptable ^Expr [^Expr to ^Expr from]
             ;; Return `to` if `from` can be adapted to `to`, and nil
             ;; otherwise.
             (let [to-tp (x/type to), from-tp (x/type from)]
               (when (or (jb/void? from-tp)
                         (tp/adaptable-to? from-tp to-tp)
                         (and (jb/reference? to-tp)
                              (x/pushes-nil-object? from)))
                 to)))]
     (or (when (x/same-type? x0 x1) x0)
         (path-adaptable x0 x1)
         (path-adaptable x1 x0)
         (when (and (x/reference? x0) (x/reference? x1))
           expr-some-object)       ;must differ from x/expr-nil-object
         (wrong/other (str "incompatible path types " (wrong/str* (x/type x0))
                           " and " (wrong/str* (x/type x1))))))))

(deftype AdaptForPath [^Class to-tp]
  IAdaptPath
  (apply-to-instr [_ x]
    (if-some [tc (or (tp/argument-conversion (x/type x) to-tp)
                     (when (and (jb/same-class? jb/int to-tp) (x/character? x))
                       ;; rejected by language, but ok for emitted code
                       (.primitive-to tp/int)))]
      (.adapt tc x)
      (throw (IllegalStateException. (str "to " to-tp " <- x " (x/type x))))))
  (after [this before]
    (if (and (instance? AdaptForPath before)
             (.isAssignableFrom to-tp (.to-tp ^AdaptForPath before)))
      this
      (x/adpt-comp this before)))
  (safe-instructions? [_]
    true)
  (toString [_]
    (str "afp-" (.getName to-tp))))
(def adpt-for-path ->AdaptForPath)
