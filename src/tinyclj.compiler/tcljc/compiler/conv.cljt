;; Copyright (c) Michael van Acken. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 2.0 (https://www.eclipse.org/legal/epl-v20.html)
;; which can be found in the file epl-v20.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.
(ns tcljc.compiler.conv
  (:require
   [tcljc.classfile :as cf]
   [tcljc.javabase :as jb]
   [tcljc.runtime :as rt]
   [tcljc.wrong :as wrong]
   [tcljc.expr :as x]
   [tcljc.compiler.resolve :as resolve]
   [tcljc.exprfold :as xf])
  (:import
   (tcljc.expr Expr Progn BindingRef IAdaptResult)
   (clojure.lang IPersistentVector)
   (java.lang.classfile Opcode)
   (java.lang.reflect Executable)))

(def ^:private show-class-loader false)

(letfn [(class-loader-suffix [tp]
          (when show-class-loader
            (if (class? tp)
              (if-some [ld (.getClassLoader ^Class tp)]
                (or (.getName ld) "not-named")
                nil #_"bootstrap")
              "class-desc")))]
  (defn type-str ^String [clx]
    (str (.displayName (rt/cd-of clx)) (class-loader-suffix clx))))

;;; ------------------------------------------------------------------------

;;; All `to-xxx` type conversion functions assume that their argument
;;; is numeric (which includes char, and excludes boolean), but *not*
;;; of the desired type.  The exception is `to-int`, which is
;;; idempotent for int values and also accepts a boolean argument.

(defn- to-int ^Expr [^Expr arg]         ;idempotent if `arg` is int
  (condp jb/same-class? (x/type arg)
    Integer/TYPE arg
    Long/TYPE (xf/conv jb/int arg Opcode/L2I)
    Float/TYPE (xf/conv jb/int arg Opcode/F2I)
    Double/TYPE (xf/conv jb/int arg Opcode/D2I)
    Boolean/TYPE (x/invoke-xref jb/int [arg] (.const-value arg)
                                rt/mhd-boolean-to-zero-one false)
    #_else (x/identity jb/int arg)))

(defn to-long ^Expr [^Expr arg]
  (condp jb/same-class? (x/type arg)
    Integer/TYPE (xf/conv jb/long arg Opcode/I2L)
    Float/TYPE (xf/conv jb/long arg Opcode/F2L)
    Double/TYPE (xf/conv jb/long arg Opcode/D2L)
    (recur (to-int arg))))
(defn to-float ^Expr [^Expr arg]
  (condp jb/same-class? (x/type arg)
    Integer/TYPE (xf/conv jb/float arg Opcode/I2F)
    Long/TYPE (xf/conv jb/float arg Opcode/L2F)
    Double/TYPE (xf/conv jb/float arg Opcode/D2F)
    (recur (to-int arg))))
(defn to-double ^Expr [^Expr arg]
  (condp jb/same-class? (x/type arg)
    Integer/TYPE (xf/conv jb/double arg Opcode/I2D)
    Long/TYPE (xf/conv jb/double arg Opcode/L2D)
    Float/TYPE (xf/conv jb/double arg Opcode/F2D)
    (recur (to-int arg))))

(defn- to-byte ^Expr [^Expr arg]
  (xf/conv jb/byte (to-int arg) Opcode/I2B))
(defn- to-short ^Expr [^Expr arg]
  (xf/conv jb/short (to-int arg) Opcode/I2S))
(defn- to-char ^Expr [^Expr arg]
  (xf/conv jb/char (to-int arg) Opcode/I2C))

(defn upper-numeric-tp ^Class [^Expr arg0 ^Expr arg1]
  (if (resolve/numeric-assignable-to? (x/type arg1) (x/type arg0))
    (x/type arg0)
    (x/type arg1)))

(def ^:private ^Object* aopcd-conv-to
  (into-array Object [to-int to-long to-float to-double
                      nil to-byte to-char to-short]))

(defn lookup-conv-to-fn* [^Class to-cl]
  (aget aopcd-conv-to (cf/opcode-delta to-cl)))

(defn conv-to ^Expr [^Class to-cl conv-to-fn ^Expr arg]
  (cond
    (x/type? to-cl arg) arg
    (x/numeric? arg) (conv-to-fn arg)
    
    ;; accept type conversion like (int <boolean>) to better support
    ;; certain patterns of branchless code
    (or (x/character? arg) (x/boolean? arg))
    (conv-to-fn arg)
    
    :else (x/wrong-type (str "cannot convert to " (type-str to-cl)) arg)))

(defn widen-from ^Expr [^Class to-cl ^Expr from]
  ;; pre: `from` is assignable to `to`
  (conv-to to-cl (lookup-conv-to-fn* to-cl) from))

(defn computational-int? ^boolean [^Expr x]
  (let [cl (x/type x)]
    (and (.isPrimitive cl)
         (case (.charAt (.descriptorString cl) 0)
           (\B \C \I \S \Z) true
           #_else false))))

(defn numeric-assignable-to-int? ^boolean [^Expr x]
  (let [cl (x/type x)]
    (and (.isPrimitive cl)
         (case (.charAt (.descriptorString cl) 0)
           (\B \I \S) true
           #_else false))))

(defn- to-computational-type ^Expr [^Expr from]
  (if (numeric-assignable-to-int? from)
    (widen-from jb/int from)
    from))

(defn ensure-numeric ^Expr [^Expr from]
  (if (x/numeric? from)
    (to-computational-type from)
    (x/wrong-type "expect numeric expression" from)))

;;; ------------------------------------------------------------------------

(defn primitive-conv-from-object ^Expr [^Class to-tp ^Expr arg]
  (if (x/type? (rt/logical->box to-tp) arg)
    (xf/primitive-unbox-expr to-tp arg)
    (x/invoke-xref to-tp [arg] (rt/logical->conv-object-mhd to-tp))))

(defn box-expr ^Expr [^Expr prim-expr] ;pre: `prim-expr` is of primitive type
  (let [from-tp (x/type prim-expr)]
    (x/invoke-xref (rt/logical->box from-tp) [prim-expr]
                   (rt/logical->box-factory from-tp))))

(defn box-any-expr ^Expr [^Expr x]
  (cond
    (x/statement? x) x/expr-nil-object
    (x/reference? x) (x/identity x)
    :else (box-expr x)))

(defn expr-default ^Expr [^Class tp]
  (cond (jb/numeric? tp) (widen-from tp x/expr-zero-byte)
        (jb/same-class? jb/boolean tp) x/expr-false
        (jb/same-class? jb/char tp) x/expr-zero-char
        (jb/statement? tp) x/expr-empty
        ;; anything else that produces a value is currently a
        ;; reference type
        :else (x/const tp nil)))

;;; ------------------------------------------------------------------------

(defn- jvm-adapt-to ^Expr [^Class to-tp ^Expr from] ;returns nil on failure
  (let [from-tp (x/type from)]
    (cond
      (or (x/type? to-tp from)      ;cheapest: type of `from` is `to-tp`
          (jb/polymorphic? to-tp))
      from

      (or (jb/jvm-assignable-to? from-tp to-tp)
          (rt/unboxing-assignable-to? from-tp to-tp)
          (and (x/pushes-nil-object? from) (jb/reference? to-tp)))
      (xf/coerce from to-tp)            ;widen

      (jb/statement? to-tp)
      (xf/coerce-to-statm from)

      (resolve/numeric-assignable-to? from-tp to-tp)
      (widen-from to-tp from)
      
      :else nil)))

(letfn [(adapt-for-assign ^Expr [^Expr from ^Class to-tp]
          (let [from-cl (x/type from)
                to-cl to-tp]
            (or (jvm-adapt-to to-tp from)

                (when (x/statement? from)
                  (xf/prog2-expr from (expr-default to-tp)))
        
                (when (jb/reference? to-tp)
                  (cond (jb/jvm-assignable-to? to-cl from-cl)
                        (xf/coerce from to-tp) ;narrow

                        (jb/same-class? Void/TYPE from-cl)
                        (xf/prog2-expr from (x/const to-tp nil))
                
                        :else nil)))))
        (wrong-assign ^void [^Expr from ^Class to-tp ^String to-description]
          (x/wrong-type (str "cannot assign to " (wrong/q to-tp) to-description)
                        from))]
  
  ;; Transform `x` into a type that can be represented as a non-void
  ;; type descriptor.  In particular, void is turned into an expression that
  ;; pushes a nil operand of type Object.
  ;; 
  ;; pre: `x` is a runtime value & not polymorphic.
  (defn consume-poly ^Expr [^Expr x]
    (let [x-tp (x/type x)]
      (if (jb/statement? x-tp)
        (xf/prog2-expr x x/expr-nil-object)
        x)))

  ;; Transform `x` into a type that is assignment compatible to type
  ;; `to-tp`.  If `to-tp` is jb/polymorphic?, this function delegates
  ;; to `consume-poly`.
  ;; 
  ;; pre: `x` is a runtime value & not polymorphic.
  (defn consume ^Expr [^Expr x ^Class to-tp to-form]
    (if (jb/polymorphic? to-tp)
      (consume-poly x)
      (or (adapt-for-assign x to-tp)
          (wrong-assign x to-tp (when (some? to-form)
                                  (str " of " (wrong/q-symbol to-form)))))))
  (defn consume-for ^Expr [^Expr x ^BindingRef bref]
    ;; FIXME... `x/form` is nil for imported parameters because
    ;; reflection does not offer this information
    (consume x (x/type bref) (x/form bref)))

  ;; Special case of `consume` which passes on an expression `x` if
  ;; `to-tp` is polymorphic.
  (defn consume-body ^Expr [^Expr x ^Class to-tp ^String to-result]
    (if (jb/polymorphic? to-tp)
      x
      (or (adapt-for-assign x to-tp)
          (wrong-assign x to-tp (str " of " to-result))))))

;;; ------------------------------------------------------------------------

;; Return `to` if `from` can be widened to `to`, and nil otherwise.
(defn- path-adaptable ^Expr [^Expr to ^Expr from]
  (when (or (not (x/pushes-result? from))
            (resolve/numeric-assignable-to? (x/type from) (x/type to))
            (and (x/pushes-nil-object? from) (x/reference? to)))
    to))

(def ^:private expr-some-object (x/const jb/Object "expr-some-object"))
(defn path-join
  (^Expr [xs]
   (reduce path-join (first xs) (rest xs)))
  (^Expr [^Expr x0 ^Expr x1]
   (or (when (x/same-type? x0 x1)
         x0)
       (path-adaptable x0 x1)
       (path-adaptable x1 x0)
       (when (and (x/reference? x0) (x/reference? x1))
         expr-some-object)         ;must differ from x/expr-nil-object
       (wrong/other (str "incompatible path types " (wrong/str* (x/type x0))
                         " and " (wrong/str* (x/type x1)))))))
(defn- adapt-for-path ^Expr [^Expr from ^Class to-tp]
  (or (jvm-adapt-to to-tp from)
      (cond ;non-Java type conversions are possible for paths!
        (x/statement? from) ;case "no return" is handled by jvm-adapt-to
        (xf/prog2-expr from (expr-default to-tp))
        
        (and (jb/same-class? jb/int to-tp) (x/character? from))
        (widen-from jb/int from) ;rejected by language, but ok for emitted code
        
        :else
        (throw (IllegalStateException. (str "to " to-tp " <- from "
                                            (x/type from)))))))

(deftype AdaptForPath [^Class to-tp]
  IAdaptResult
  (apply-to-instr [_ x]
    (adapt-for-path x to-tp))
  (after [this before]
    (if (and (instance? AdaptForPath before)
             (.isAssignableFrom to-tp (.to-tp ^AdaptForPath before)))
      this
      (x/adpt-comp this before)))
  (safe-instructions? [_]
    true)
  (toString [_]
    (str "afp-" (.getName to-tp))))
(def adpt-for-path ->AdaptForPath)
