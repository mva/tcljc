;; Copyright (c) Michael van Acken. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 2.0 (https://www.eclipse.org/legal/epl-v20.html)
;; which can be found in the file epl-v20.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.
(ns tcljc.compiler.invoke
  (:require
   [tcljc.javabase :as jb]
   [tcljc.runtime :as rt]
   [tcljc.wrong :as wrong]
   [tcljc.expr :as x]
   [tcljc.type :as tp]
   [tcljc.compiler.resolve :as resolve])
  (:import
   (tcljc.expr Expr)
   (tcljc.type TypeConversion)
   (clojure.lang IPersistentVector)
   (java.lang.constant MethodHandleDesc ConstantDescs
                       ClassDesc DirectMethodHandleDesc$Kind)
   (java.lang.reflect Executable Field Method Constructor Modifier)))

(deftype ArgSig [^Class* atypes, ^boolean* anils]
  java.lang.Record)

(defn- arg-sig ^ArgSig [^IPersistentVector argv ^int start]
  ;; note: `atypes` of virtual methods and fields omits argv[0]
  (let [n (- (count argv) start)
        atypes (new Class* n)
        anils (new boolean* n)]
    (dotimes [i n]
      (let [x ^Expr (nth argv (+ i start))]
        (aset atypes i (x/type x))
        (aset anils i (x/pushes-nil-object? x))))
    (ArgSig. atypes anils)))

(defn- arg-count ^int [^ArgSig as]
  (alength (.atypes as)))
(defn- vararg-count ^int [^ArgSig as ^int n-fixargs]
  (- (arg-count as) n-fixargs))
(defn- last-arg-type ^Class [^ArgSig as]
  (aget (.atypes as) (dec (arg-count as))))

(defn- arg-conversion ^TypeConversion [^ArgSig as ^int aidx ^Class ptype]
  (if (and (jb/primitive? ptype) (aget (.anils as) aidx))
    nil           ;do not match untyped nil with primitive parameter
    (tp/argument-conversion (aget (.atypes as) aidx) ptype)))


;;; Problem: class MethodHandle.PolymorphicSignature is not public
(def ^:private ann-polymorphic-signature
  (Class/forName "java.lang.invoke.MethodHandle$PolymorphicSignature"
                 false (ClassLoader/getPlatformClassLoader)))

(deftype Alignment [^Executable exec
                    ^TypeConversion* fixargs
                    ^TypeConversion* varargs
                    ^Class va-array-type]) ;array type, or nil if polymorphic

(letfn [(signature-polymorphic? ^boolean [^Executable e] ;pre: e.isVarArgs()
          (and (instance? Method e)
               (.isAnnotationPresent ^Method e ann-polymorphic-signature)))
        
        (fixarg-conversions ^TypeConversion* [^ArgSig as ^int n-fixargs
                                              ^Class* ptypes]
          (let [atc (new TypeConversion* n-fixargs)]
            (loop [i 0]
              (if (< i n-fixargs)
                (when-some [tc (arg-conversion as i (aget ptypes i))]
                  (aset atc i tc)
                  (recur (inc i)))
                atc))))
        (polyarg-conversions ^TypeConversion* [^ArgSig as ^int n-fixargs]
          (let [n-varargs (vararg-count as n-fixargs)]
            (doto (new TypeConversion* n-varargs)
              (java.util.Arrays/fill tp/tc-identity))))
        (vararg-conversions ^TypeConversion* [^ArgSig as ^int n-fixargs
                                              ^Class va-arg-type]
          (let [n-varargs (vararg-count as n-fixargs)]
            (let [atc (new TypeConversion* n-varargs)]
              (loop [i 0]
                (if (< i n-varargs)
                  (when-some [tc (arg-conversion as (+ n-fixargs i) va-arg-type)]
                    (aset atc i tc)
                    (recur (inc i)))
                  atc)))))
        
        (conj-args [acc argv ^TypeConversion* fixargs]
          (let [offset (count acc)      ;receiver or fixargs present?
                n (alength fixargs)]
            (loop [acc acc, i 0]
              (if (< i n)
                (let [arg' (.adapt (aget fixargs i) (nth argv (+ i offset)))]
                  (recur (conj acc arg') (inc i)))
                acc))))
        (varargs-array ^Expr [argv ^Class va-array-type ^TypeConversion* varargs]
          (let [n (alength varargs)
                offset (- (count argv) n)]
            (loop [acc (transient []), i 0]
              (if (< i n)
                (recur (conj! acc (.adapt (aget varargs i)
                                          (nth argv (+ i offset))))
                       (inc i))
                (x/array-of (persistent! acc) va-array-type)))))
        (invoke-without-receiver? ^boolean [^Executable e]
          (or (Modifier/isStatic (.getModifiers e))
              (instance? Constructor e)))]
  
  (defn- alignment ^Alignment [^ArgSig as ^Executable e]
    ;; pre: (parameter-count-match? atypes e)
    (let [ptypes (.getParameterTypes e)
          varargs? (and (.isVarArgs e)
                        (not (and (= (arg-count as) (alength ptypes))
                                  (jb/jvm-assignable-to?
                                   (last-arg-type as)
                                   (aget ptypes (dec (alength ptypes)))))))
          n-fixargs (cond-> (alength ptypes)
                      varargs? (dec))]
      (when-some [fixargs (fixarg-conversions as n-fixargs ptypes)]
        (if varargs?
          (let [array-tp (aget ptypes (dec (alength ptypes)))
                arg-tp (.getComponentType array-tp)]
            (if (signature-polymorphic? e)
              (Alignment. e fixargs (polyarg-conversions as n-fixargs) nil)
              (when-some [varargs (vararg-conversions as n-fixargs arg-tp)]
                (Alignment. e fixargs varargs array-tp))))
          (Alignment. e fixargs nil nil)))))

  (defn as-vararg-array ^Expr [^IPersistentVector argv ^Class va-array-type]
    (let [as (arg-sig argv 0)
          atc (vararg-conversions as 0 (.getComponentType va-array-type))]
      (varargs-array argv va-array-type atc)))
  
  (defn- invocation-argv [argv ^Alignment align]
    (cond-> (if (invoke-without-receiver? (.exec align)) [] [(nth argv 0)])
      ;; fixed arguments follow receiver, if one is present
      true
      (conj-args argv (.fixargs align))

      ;; regular varargs are wrapped in an array
      (and (some? (.varargs align)) (some? (.va-array-type align)))
      (conj (varargs-array argv (.va-array-type align) (.varargs align)))
      
      ;; polymorphic varargs are appended unchanged
      (and (some? (.varargs align)) (nil? (.va-array-type align)))
      (conj-args argv (.varargs align)))))

;;; ------------------------------------------------------------------------

(defn- conj-alignment [acc ^ArgSig as ^Executable e]
  (let [align (alignment as e)]
    (cond-> acc (some? align) (conj align))))

(defn- parameter-count-match? ^boolean [^ArgSig as ^Executable e]
  (let [n-p (.getParameterCount e)
        n-a (arg-count as)]
    (or (= n-p n-a) (and (.isVarArgs e) (>= n-a (dec n-p))))))

(letfn [(compatible-args? ^boolean [^ArgSig as ^Executable e]
          (and (parameter-count-match? as e) (some? (alignment as e))))
        (parameter-sig ^ArgSig [^Executable e]
          (let [ptypes (.getParameterTypes e)]
            (ArgSig. ptypes (new boolean* (alength ptypes)))))]
  
  (defn- filter-dominators [es]
    (letfn [(dominates-all? ^boolean [^Executable e]
              (let [ps (parameter-sig e)]
                (every? #(compatible-args? ps %) es)))]
      (if (next es) ;nothing to do if there are less than two elements
        (or (seq (filter dominates-all? es)) es)
        es)))
  
  (defn- dominating-alignments [aligns]
    (letfn [(dominates-all? ^boolean [^Alignment align]
              (let [ps (parameter-sig (.exec align))]
                (every? #(compatible-args? ps (.exec ^Alignment %)) aligns)))]
      (if (next aligns) ;nothing to do if there are less than two elements
        (or (seq (filter dominates-all? aligns)) aligns)
        aligns))))

;;; ------------------------------------------------------------------------

(defn- methods-with [^int opts ^Class owner ^String nm ^ArgSig as]
  (let [ms (.getMethods owner)]
    (loop [acc (), i (dec (alength ms))]
      (if (neg? i)
        acc
        (let [m (aget ms i)]
          (recur (cond-> acc
                   (and (= nm (.getName m))
                        (resolve/static-virtual-match? opts m)
                        (parameter-count-match? as m)
                        (not (.isBridge m)))
                   (conj-alignment as m))
                 (dec i)))))))

(defn- constructors-with [^Class owner ^ArgSig as]
  (let [cs (.getConstructors owner)]
    (loop [acc (), i (dec (alength cs))]
      (if (neg? i)
        acc
        (let [c (aget cs i)]
          (recur (cond-> acc
                   (parameter-count-match? as c)
                   (conj-alignment as c))
                 (dec i)))))))

(letfn [(pick-alignment ^Alignment [[^Alignment align & alignr]]
          (when (and (some? align) (nil? alignr))
            align))
        (wrong-member [aligns ^String member-label ^Class owner ^String nm
                       ^ArgSig as]
          (letfn [(invoke-ex-data []
                    {:invoke/name nm
                     :invoke/owner owner
                     :invoke/arg-types (.atypes as)})]
            (if-some [as (seq aligns)]
              (-> (str "multiple " member-label "s matching ")
                  (wrong/unresolved-interop nm owner (invoke-ex-data)))
              (-> (str "no " member-label " matching ")
                  (wrong/unresolved-interop nm owner (invoke-ex-data))))))
        
        (settable? ^boolean [^Field f]
          (not (Modifier/isFinal (.getModifiers f))))

        (invoke-method* ^Expr [^long x-env ^DirectMethodHandleDesc$Kind k
                               ^ClassDesc owner ^Method m
                               ^IPersistentVector argv]
          (let [desc (-> (rt/mtd-of (.getReturnType m) (.getParameterTypes m))
                         (.descriptorString))
                mhd (MethodHandleDesc/of k owner (.getName m) desc)]
            (x/invoke-xref x-env (.getReturnType m) argv nil mhd false)))
        (invoke-method ^Expr [^long x-env ^DirectMethodHandleDesc$Kind k
                              ^ClassDesc owner ^Alignment align
                              ^IPersistentVector argv]
          (let [m ^Method (.exec align)
                argv (invocation-argv argv align)]
            (if (and (some? (.varargs align)) (nil? (.va-array-type align)))
              (x/invoke-poly x-env jb/cl-polymorphic-type argv nil k
                             owner (.getName m) (.isInterface k))
              (invoke-method* x-env k owner m argv))))

        (invoke-constr* ^Expr [^long x-env ^Class owner ^Constructor c
                               ^IPersistentVector argv]
          (let [desc (-> (rt/mtd-of rt/void (.getParameterTypes c))
                         (.descriptorString))
                mhd (MethodHandleDesc/of rt/mhk-constructor
                                         (rt/describe-class owner)
                                         ConstantDescs/INIT_NAME desc)]
            (x/invoke-xref x-env owner argv nil mhd false)))
        (invoke-constr ^Expr [^long x-env ^Class owner
                              ^Alignment align ^IPersistentVector argv]
          (let [c ^Constructor (.exec align)
                argv (invocation-argv argv align)]
            (invoke-constr* x-env owner c argv)))]

  ;; pre: At least one of `flag-field` or `flag-method` is set.
  ;; Exactly one of `flag-static` or `flag-virtual` is set.
  (defn- member* ^Expr [^long x-env ^Class owner ^String nm
                        ^IPersistentVector argv ^int opts]
    (let [as (arg-sig argv (resolve/first-argument-index opts))
          owner-cd (if (jb/array? owner) rt/object (rt/describe-class owner))
          k (resolve/method-kind (bit-test opts resolve/flag-static) owner)]
      
      (letfn [(wrong [ms]
                (wrong-member ms
                              (str (if (bit-test opts resolve/flag-static)
                                     "static"
                                     "virtual")
                                   (cond (resolve/fields-only? opts) " field"
                                         (resolve/methods-only? opts) " method"
                                         :else " member"))
                              owner nm as))
          
              (load-field []
                (try
                  (let [f (.getField owner nm)]
                    (if (and (resolve/static-virtual-match? opts f)
                             (zero? (arg-count as)))
                      (let [mhd (MethodHandleDesc/ofField
                                 (resolve/field-kind (bit-test opts resolve/flag-static))
                                 (rt/describe-class owner) (.getName f)
                                 (rt/cd-of (.getType f)))]
                        (x/invoke-xref x-env (.getType f) argv nil mhd
                                       (settable? f)))
                      (wrong ())))
                  (catch NoSuchFieldException _
                    (wrong ()))))]

        (if (resolve/fields-only? opts)
          (load-field)
          (if-some [m (resolve/method-exact opts owner nm (.atypes as))]
            (invoke-method* x-env k owner-cd m argv)
            ;; `atypes` does not include receiver, but the receiver is
            ;; counted as an implicit invocation argument
            (if-some [ms (seq (->> (methods-with opts owner nm as)
                                   (dominating-alignments)))]
              (if-some [align (pick-alignment ms)]
                (invoke-method x-env k owner-cd align argv)
                (wrong ms))
              (if (resolve/methods-only? opts)
                (wrong ())
                (load-field))))))))

  (defn member ^Expr [^long x-env ^Class owner ^String nm
                      ^IPersistentVector argv ^int opts]
    (if (.startsWith nm "-")
      (member* x-env owner (.substring nm 1) argv
               (bit-set opts resolve/flag-field))
      (member* x-env owner nm argv
               (cond-> (bit-set opts resolve/flag-method)
                 (= (count argv) (resolve/first-argument-index opts))
                 (bit-set resolve/flag-field)))))

  (defn method ^Expr [^long x-env ^Class owner ^String nm
                      ^IPersistentVector argv ^int opts]
    (member* x-env owner nm argv
             (bit-set opts resolve/flag-method)))

  (defn constructor ^Expr [^long x-env ^Class owner ^IPersistentVector argv]
    (let [nm ConstantDescs/INIT_NAME
          as (arg-sig argv 0)]
      (if-some [c (try
                    (.getConstructor owner (.atypes as))
                    (catch NoSuchMethodException _
                      nil))]
        (invoke-constr* x-env owner c argv)
        (let [cs (->> (constructors-with owner as)
                      (dominating-alignments))]
          (if-some [align (pick-alignment cs)]
            (invoke-constr x-env owner align argv)
            (wrong-member cs "constructor" owner nm as)))))))
