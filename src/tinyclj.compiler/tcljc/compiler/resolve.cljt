;; Copyright (c) Michael van Acken. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 2.0 (https://www.eclipse.org/legal/epl-v20.html)
;; which can be found in the file epl-v20.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.
(ns tcljc.compiler.resolve
  (:require
   [tcljc.javabase :as jb]
   [tcljc.runtime :as rt]
   [tcljc.expr :as x]
   [tcljc.type :as tp])
  (:import
   (tcljc.expr Expr InvokeXref)
   (clojure.lang IPersistentVector)
   (java.lang.constant MethodHandleDesc ConstantDescs)
   (java.lang.reflect Executable Field Method Constructor Modifier)
   (java.util Arrays)))

(defn- assignable-to? ^boolean [^Class from-tp ^Class to-tp]
  (cond
    (identical? to-tp from-tp)
    true

    (or (jb/primitive? to-tp) (jb/primitive? from-tp))
    (tp/numeric-assignable-to? from-tp to-tp)

    (and (jb/reference? to-tp) (jb/object? from-tp))
    true
    
    :else (.isAssignableFrom to-tp from-tp)))


(defn fields-with [^boolean static? ^Class owner ^String nm]
  (try
    (let [f (.getField owner nm)]
      (when (= (Modifier/isStatic (.getModifiers f)) static?)
        [f]))
    (catch NoSuchFieldException _
      nil)))

(defn- invocation-parameter-count ^int [^Executable e]
  (cond-> (.getParameterCount e)
    (and (instance? Method e)           ;exclude Constructor
         (not (Modifier/isStatic (.getModifiers e))))
    (inc)))                      ;receiver is passed as extra argument

(letfn [(parameter-count-match? ^boolean [^int arg-count ^Executable e]
          (let [n (invocation-parameter-count e)]
            (or (= n arg-count)
                (and (.isVarArgs e) (>= arg-count (dec n))))))]

  (defn methods-exact [^boolean static? ^Class owner ^String nm
                       ^Class* atypes]
    ;; returns nil if there is no exact match
    (letfn [(match-static [^Method m]
              (when (= (Modifier/isStatic (.getModifiers m)) static?)
                (list m)))]
      (try
        (match-static (.getMethod owner nm atypes))
        (catch NoSuchMethodException _
          (when (jb/interface? owner)
            (try ;if owner is an interface, then try again with Object
              (match-static (.getMethod Object nm atypes))
              (catch NoSuchMethodException _
                nil)))))))
  
  (defn methods-with [^boolean static? ^Class owner ^String nm ^int arg-count]
    (filter (fn ^boolean [^Method m]
              (and (= nm (.getName m))
                   (= (Modifier/isStatic (.getModifiers m)) static?)
                   (parameter-count-match? arg-count m)
                   (not (.isBridge m))))
            (.getMethods owner)))

  (defn constructors-exact [^Class owner ^Class* atypes]
    ;; returns nil if there is no exact match
    (try
      (list (.getConstructor owner atypes))
      (catch NoSuchMethodException _
        nil)))
  
  (defn constructors-with [^Class owner ^int arg-count]
    (filter (fn ^boolean [^Constructor c]
              (parameter-count-match? arg-count c))
            (.getConstructors owner))))


(letfn [(settable? ^boolean [^Field f]  ;pre: `f` is public
          (not (Modifier/isFinal (.getModifiers f))))]

  (defn load-static ^Expr [^long x-env ^Class owner ^Field f
                           ^IPersistentVector argv]
    (let [mhd (MethodHandleDesc/ofField rt/mhk-static-getter
                                        (rt/describe-class owner) (.getName f)
                                        (rt/cd-of (.getType f)))]
      (x/invoke-xref x-env (.getType f) argv nil mhd (settable? f))))
  (defn static-fields [^Class owner ^String nm ^Class* atypes]
    (when (zero? (alength atypes))
      (fields-with true owner nm)))

  (defn load-virtual ^Expr [^long x-env ^Class owner ^Field f
                            ^IPersistentVector argv]
    (let [mhd (MethodHandleDesc/ofField rt/mhk-getter
                                        (rt/describe-class owner) (.getName f)
                                        (rt/cd-of (.getType f)))]
      (x/invoke-xref x-env (.getType f) argv nil mhd (settable? f))))
  (defn virtual-fields [^Class owner ^String nm ^Class* atypes]
    (when (zero? (alength atypes))
      (fields-with false owner nm))))

;;; Problem: class MethodHandle.PolymorphicSignature is not public
(def ^:private ann-polymorphic-signature
  (Class/forName "java.lang.invoke.MethodHandle$PolymorphicSignature"
                 false (ClassLoader/getPlatformClassLoader)))

(letfn [(compatible-prefix? ^boolean [^Class* atypes
                                      ^Class* ptypes
                                      ^int pdelta-end]
          (loop [i (+ (alength ptypes) pdelta-end)]
            (cond
              (neg? i) true
              (assignable-to? (aget atypes i) (aget ptypes i)) (recur (dec i))
              :else false)))
        (compatible-suffix? ^boolean [^Class* atypes
                                      ^Class ptype ^int start]
          (or (jb/object? ptype) ;FIXME... drop special case after Valhalla?
              (loop [i (dec (alength atypes))]
                (cond
                  (< i start) true
                  ;; FIXME... does this require special handling of
                  ;; primitives once the special case Object is gone?
                  (.isAssignableFrom ptype (aget atypes i)) (recur (dec i))
                  :else false))))
        
        (compatible-fix-args? ^boolean [^Class* atypes
                                        ^Class* ptypes]
          (and (= (alength atypes) (alength ptypes))
               (compatible-prefix? atypes ptypes -1)))
        (compatible-var-args? ^boolean [^Class* atypes
                                        ^Class* ptypes]
          (and (>= (alength atypes) (dec (alength ptypes)))
               (compatible-prefix? atypes ptypes -2)
               (let [va-tp (aget ptypes (dec (alength ptypes)))]
                 (compatible-suffix? atypes (.getComponentType va-tp)
                                     (dec (alength ptypes))))))
        (compatible-var-array? ^boolean [^Class* atypes
                                         ^Class* ptypes]
          (and (= (alength atypes) (alength ptypes))
               (.isAssignableFrom (aget ptypes (dec (alength ptypes)))
                                  (aget atypes (dec (alength atypes))))
               (compatible-prefix? atypes ptypes -2)))

        (signature-polymorphic* ^boolean [^Method m] ;pre: m.isVarArgs()
          (.isAnnotationPresent m ann-polymorphic-signature))]
  
  (defn signature-polymorphic? ^boolean [^Executable e] ;pre: e.isVarArgs()
    (and (instance? Method e) (signature-polymorphic* ^Method e)))
  
  (defn- compatible-args? ^boolean [^Class* atypes ^Executable e]
    (let [ptypes (.getParameterTypes e)]
      (if (.isVarArgs e)
        (or (compatible-var-args? atypes ptypes)
            (compatible-var-array? atypes ptypes)
            (signature-polymorphic? ^Method e))
        (compatible-fix-args? atypes ptypes))))
  
  (defn- filter-dominators [es]
    (letfn [(dominates-all? ^boolean [^Executable e]
              (every? #(compatible-args? (.getParameterTypes e) %) es))
            (filter-dominators* [es]
              (if (next es)
                (filter dominates-all? es)
                es))]
      (or (seq (filter-dominators* es)) es))))

(letfn [(method-descriptor ^String [^Method m]
          (-> (rt/mtd-of (.getReturnType m) (.getParameterTypes m))
              (.descriptorString)))

        (invoke-via-method-handle? ^boolean [^Executable e
                                             ^IPersistentVector argv]
          (and (.isVarArgs e)
               (or (not= (invocation-parameter-count e) (count argv))
                   (let [ptypes (.getParameterTypes e)
                         ptype (aget ptypes (dec (alength ptypes)))
                         atype (x/type (peek argv))]
                     (not (.isAssignableFrom ptype atype))))))]

  (defn invoke-constr ^Expr [^long x-env ^Class owner ^Constructor c
                             ^IPersistentVector argv]
    (let [owner-cd (rt/describe-class owner)
          desc (-> (rt/mtd-of rt/void (.getParameterTypes c))
                   (.descriptorString))]
      (if (invoke-via-method-handle? c argv)
        (x/mh-invoke-xref x-env owner argv nil rt/mhk-constructor
                          owner-cd ConstantDescs/INIT_NAME desc)
        (let [mhd (MethodHandleDesc/of rt/mhk-constructor owner-cd
                                       ConstantDescs/INIT_NAME desc)]
          (x/invoke-xref x-env owner argv nil mhd false)))))
  (defn constructors [^Class owner ^Class* atypes]
    (or (constructors-exact owner atypes)
        (->> (constructors-with owner (alength atypes))
             (filter #(compatible-args? atypes %))
             (filter-dominators))))

  (defn invoke-static ^Expr [^long x-env ^Class owner ^Method m
                             ^IPersistentVector argv]
    (let [owner-cd (rt/describe-class owner)
          k (if (.isInterface owner)
              rt/mhk-interface-static
              rt/mhk-static)]
      (cond
        (signature-polymorphic? m)
        (x/invoke-poly x-env jb/cl-polymorphic-type argv nil k owner-cd (.getName m)
                       (.isInterface owner))

        (invoke-via-method-handle? m argv)
        (x/mh-invoke-xref x-env (.getReturnType m) argv nil k
                          owner-cd (.getName m) (method-descriptor m))

        :else
        (let [mhd (MethodHandleDesc/of k owner-cd (.getName m)
                                       (method-descriptor m))]
          (x/invoke-xref x-env (.getReturnType m) argv nil mhd false)))))
  (defn static-methods [^Class owner ^String nm ^Class* atypes]
    (or (methods-exact true owner nm atypes)
        (->> (methods-with true owner nm (alength atypes))
             (filter #(compatible-args? atypes %))
             (filter-dominators))))

  (defn invoke-virtual ^Expr [^long x-env ^Class owner ^Method m
                              ^IPersistentVector argv]
    (let [owner-cd (if (jb/array? owner) rt/object (rt/describe-class owner))
          k (if (.isInterface owner)
              rt/mhk-interface-virtual
              rt/mhk-virtual)]
      (cond
        (signature-polymorphic? m)
        (x/invoke-poly x-env jb/cl-polymorphic-type argv nil k
                       owner-cd (.getName m) (.isInterface owner))

        (invoke-via-method-handle? m argv)
        (x/mh-invoke-xref x-env (.getReturnType m) argv nil k
                          owner-cd (.getName m) (method-descriptor m))

        :else
        (let [mhd (MethodHandleDesc/of k owner-cd (.getName m)
                                       (method-descriptor m))]
          (x/invoke-xref x-env (.getReturnType m) argv nil mhd false)))))
  (defn virtual-methods [^Class owner ^String nm ^Class* atypes]
    ;; `atypes` does not include receiver, but the receiver is counted
    ;; as an implicit invocation argument
    (or (methods-exact false owner nm atypes)
        (->> (methods-with false owner nm (inc (alength atypes)))
             (filter #(compatible-args? atypes %))
             (filter-dominators)))))

;;; ------------------------------------------------------------------------

(letfn [(vp? ^boolean [^Method m]
          (let [mods (.getModifiers m)]
            (and (not (Modifier/isStatic mods))
                 (Modifier/isProtected mods)
                 (not (.isBridge m)))))
        (protected-methods [^Class cl]
          (when (some? cl)
            (lazy-seq
             (concat (filter vp? (.getDeclaredMethods cl))
                     (protected-methods (.getSuperclass cl))))))
        (vpp? ^boolean [^Method m]
          (let [mods (.getModifiers m)]
            (and (not (Modifier/isStatic mods))
                 (or (Modifier/isPublic mods) (Modifier/isProtected mods))
                 (not (.isBridge m)))))
        (public-or-protected-methods [^Class cl]
          (concat
           (filter vpp? (.getMethods cl)) ;all public methods (incl. inherited)
           (protected-methods cl))) ;protected methods from superclass chain

        ;; Picks up any matching virtual method, public *or*
        ;; protected.  Used to override protected method in reify*.
        (methods-exact-pp [^Class owner ^String nm ^Class* ptypes]
          (->> (public-or-protected-methods owner)
               (filter (fn ^boolean [^Method m]
                         (and
                          (= (.getName m) nm)
                          (Arrays/equals (.getParameterTypes m) ptypes))))))

        (drop-equal-parameters [ms]
          ;; get rid of any matches with different owners by equal
          ;; parameter types, like
          ;; (.containsKey ^boolean [clojure.lang.Associative Object]
          ;; (.containsKey ^boolean [java.util.Map Object]
          (if (next ms)
            (let [m ^Method (first ms)
                  pred (fn ^boolean [^Method o]
                         (and (= (.isVarArgs m) (.isVarArgs o))
                              (Arrays/equals (.getParameterTypes m)
                                             (.getParameterTypes o))))]
              (cons m (lazy-seq (->> (remove pred (rest ms))
                                     (drop-equal-parameters)))))
            ms))]
  
  ;; Picks up public or protected virtual method.
  (defn itf-methods-with-name [^Class owner ^String nm ^int arity]
    (->> (public-or-protected-methods owner)
         (filter (fn ^boolean [^Method m]
                   (and (= nm (.getName m))
                        (= arity (.getParameterCount m)))))
         (filter-dominators)
         (drop-equal-parameters)))

  ;; If `return-type` is not cl-polymorphic-type, then it must match
  ;; the the return type of the method.
  (defn itf-method-exact ^Method [^Class owner ^String nm ^Class return-type
                                  ^Class* atypes]
    (when-some [^Method m (->> (or (methods-exact false owner nm atypes)
                                   (methods-exact-pp owner nm atypes))
                               (first))]
      (when (or (jb/polymorphic? return-type)
                (jb/same-class? (.getReturnType m) return-type))
        m))))

(letfn [(functional-itf? ^boolean [^Class cl]
          (some? (.getAnnotation cl java.lang.FunctionalInterface)))
        (object-method? ^boolean [^Method m]
          (try
            (let [m* (.getMethod Object (.getName m) (.getParameterTypes m))]
              (and (jb/same-class? (.getReturnType m) (.getReturnType m*))
                   (= (.isVarArgs m) (.isVarArgs m*))))
            (catch NoSuchMethodException _
              false)))
        (abstract-method? ^boolean [^Method m]
          (Modifier/isAbstract (.getModifiers m)))]
  (defn itf-methods [^Class itf]
    (let [ms (.getDeclaredMethods itf)]
      (if (functional-itf? itf)
        (let [abs-ms (->> (filter abstract-method? ms)
                          (remove object-method?))]
          (assert (= (count abs-ms) 1))
          abs-ms)
        (filter abstract-method? ms)))))
