;; Copyright (c) Michael van Acken. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 2.0 (https://www.eclipse.org/legal/epl-v20.html)
;; which can be found in the file epl-v20.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.
(ns tcljc.compiler.resolve
  (:require
   [tcljc.javabase :as jb]
   [tcljc.runtime :as rt]
   [tcljc.wrong :as wrong]
   [tcljc.expr :as x]
   [tcljc.type :as tp]
   [tcljc.compiler.conv :as conv])
  (:import
   (tcljc.expr Expr InvokeXref)
   (clojure.lang IPersistentVector)
   (java.lang.constant MethodHandleDesc ConstantDescs
                       ClassDesc DirectMethodHandleDesc$Kind)
   (java.lang.reflect Executable Field Method Constructor Modifier)
   (java.util Arrays)))

(deftype Alignment [^Executable exec])

(defn- assignable-to? ^boolean [^Class from-tp ^Class to-tp]
  (cond
    (identical? to-tp from-tp)
    true

    (or (jb/primitive? to-tp) (jb/primitive? from-tp))
    (tp/adaptable-to? from-tp to-tp)

    (and (jb/reference? to-tp) (jb/object? from-tp))
    true
    
    :else (.isAssignableFrom to-tp from-tp)))


;;; Problem: class MethodHandle.PolymorphicSignature is not public
(def ^:private ann-polymorphic-signature
  (Class/forName "java.lang.invoke.MethodHandle$PolymorphicSignature"
                 false (ClassLoader/getPlatformClassLoader)))

(letfn [(compatible-prefix? ^boolean [^Class* atypes
                                      ^Class* ptypes
                                      ^int pdelta-end]
          (loop [i (+ (alength ptypes) pdelta-end)]
            (cond
              (neg? i) true
              (assignable-to? (aget atypes i) (aget ptypes i)) (recur (dec i))
              :else false)))
        (compatible-suffix? ^boolean [^Class* atypes
                                      ^Class ptype ^int start]
          (or (jb/object? ptype) ;FIXME... drop special case after Valhalla?
              (loop [i (dec (alength atypes))]
                (cond
                  (< i start) true
                  ;; FIXME... does this require special handling of
                  ;; primitives once the special case Object is gone?
                  (.isAssignableFrom ptype (aget atypes i)) (recur (dec i))
                  :else false))))
        
        (compatible-fix-args? ^boolean [^Class* atypes
                                        ^Class* ptypes]
          (and (= (alength atypes) (alength ptypes))
               (compatible-prefix? atypes ptypes -1)))
        (compatible-var-args? ^boolean [^Class* atypes
                                        ^Class* ptypes]
          (and (>= (alength atypes) (dec (alength ptypes)))
               (compatible-prefix? atypes ptypes -2)
               (let [va-tp (aget ptypes (dec (alength ptypes)))]
                 (compatible-suffix? atypes (.getComponentType va-tp)
                                     (dec (alength ptypes))))))
        (compatible-var-array? ^boolean [^Class* atypes
                                         ^Class* ptypes]
          (and (= (alength atypes) (alength ptypes))
               (.isAssignableFrom (aget ptypes (dec (alength ptypes)))
                                  (aget atypes (dec (alength atypes))))
               (compatible-prefix? atypes ptypes -2)))

        (signature-polymorphic* ^boolean [^Method m] ;pre: m.isVarArgs()
          (.isAnnotationPresent m ann-polymorphic-signature))]
  
  (defn signature-polymorphic? ^boolean [^Executable e] ;pre: e.isVarArgs()
    (and (instance? Method e) (signature-polymorphic* ^Method e)))
  
  (defn- alignment [^Class* atypes ^Executable e]
    (when (let [ptypes (.getParameterTypes e)]
            (if (.isVarArgs e)
              (or (compatible-var-args? atypes ptypes)
                  (compatible-var-array? atypes ptypes)
                  (signature-polymorphic? ^Method e))
              (compatible-fix-args? atypes ptypes)))
      (Alignment. e)))
  (defn- conj-alignment [acc ^Class* atypes ^Executable e]
    (let [align (alignment atypes e)]
      (cond-> acc (some? align) (conj align))))
  
  (defn- filter-dominators [es]
    (letfn [(dominates-all? ^boolean [^Executable e]
              (every? #(alignment (.getParameterTypes e) %) es))]
      (if (next es) ;nothing to do if there are less than two elements
        (filter dominates-all? es)
        es)))
  (defn- dominating-alignments [aligns]
    (letfn [(dominates-all? ^boolean [^Alignment align]
              (let [ptypes (-> align .exec (.getParameterTypes))]
                (every? #(alignment ptypes (.exec ^Alignment %)) aligns)))]
      (if (next aligns) ;nothing to do if there are less than two elements
        (filter dominates-all? aligns)
        aligns))))

(defn- invoke-via-method-handle? ^boolean [^Executable e ^Class* atypes]
  (and (.isVarArgs e)
       (or (not= (.getParameterCount e) (alength atypes))
           (let [ptypes (.getParameterTypes e)
                 ptype (aget ptypes (dec (alength ptypes)))
                 atype (aget atypes (dec (alength atypes)))]
             (not (.isAssignableFrom ptype atype))))))

;;; ------------------------------------------------------------------------

(letfn [(parameter-count-match? ^boolean [^Class* atypes ^Executable e]
          (let [n (.getParameterCount e)]
            (or (= n (alength atypes))
                (and (.isVarArgs e) (>= (alength atypes) (dec n))))))]

  (defn- method-exact ^Method [^boolean static? ^Class owner ^String nm
                               ^Class* atypes]
    (letfn [(match-static ^Method [^Method m]
              (when (= (Modifier/isStatic (.getModifiers m)) static?)
                m))]
      (try
        (match-static (.getMethod owner nm atypes))
        (catch NoSuchMethodException _
          (when (jb/interface? owner)
            (try ;if owner is an interface, then try again with Object
              (match-static (.getMethod Object nm atypes))
              (catch NoSuchMethodException _
                nil)))))))
  
  (defn- methods-with [^boolean static? ^Class owner ^String nm ^Class* atypes]
    (let [ms (.getMethods owner)]
      (loop [acc (), i (dec (alength ms))]
        (if (neg? i)
          acc
          (let [m (aget ms i)]
            (recur (cond-> acc
                     (and (= nm (.getName m))
                          (= (Modifier/isStatic (.getModifiers m)) static?)
                          (parameter-count-match? atypes m)
                          (not (.isBridge m)))
                     (conj-alignment atypes m))
                   (dec i)))))))

  (defn- constructor-exact ^Constructor [^Class owner ^Class* atypes]
    ;; returns nil if there is no exact match
    (try
      (.getConstructor owner atypes)
      (catch NoSuchMethodException _
        nil)))
  
  (defn- constructors-with [^Class owner ^Class* atypes]
    (let [cs (.getConstructors owner)]
      (loop [acc (), i (dec (alength cs))]
        (if (neg? i)
          acc
          (let [c (aget cs i)]
            (recur (cond-> acc
                     (parameter-count-match? atypes c)
                     (conj-alignment atypes c))
                   (dec i))))))))

;;; ------------------------------------------------------------------------

(defn- pick-member [[^Alignment align & alignr]]
  (when (and (some? align) (nil? alignr))
    (.exec align)))
(defn- wrong-member [aligns ^String member-label ^Class owner ^String nm
                     ^Class* atypes]
  (letfn [(invoke-ex-data []
            {:invoke/name nm
             :invoke/owner owner
             :invoke/arg-types atypes})]
    (if-some [as (seq aligns)]
      (-> (str "multiple " member-label "s matching ")
          (wrong/unresolved-interop nm owner (invoke-ex-data)))
      (-> (str "no " member-label " matching ")
          (wrong/unresolved-interop nm owner (invoke-ex-data))))))


;;; Returns component type of the varargs parameter, or nil if no
;;; arguments are collected into an array.  If `e` is polymorphic,
;;; result is always `cl-polymorphic-type`.
(defn- collecting-vararg-type ^Class [^Executable e ^IPersistentVector argv]
  (when (.isVarArgs e)
    (if (signature-polymorphic? e)
      jb/cl-polymorphic-type
      (let [n (.getParameterCount e)
            va-param-tp (aget (.getParameterTypes e) (dec n))]
        (if (and (= n (count argv))
                 (.isAssignableFrom va-param-tp (x/type (peek argv))))
          nil                           ;array already provided
          (.componentType va-param-tp))))))

(defn- consume-args
  (^IPersistentVector [^IPersistentVector acc
                       ^IPersistentVector argv
                       ^Executable e]
   (let [ptypes (.getParameterTypes e)]
     (if-some [vararg-tp (collecting-vararg-type e argv)]
       ;; For a polymorphic method, skip adapting of arguments
       ;; starting with the position of the vararg parameter.  For a
       ;; varargs method, only adapt reference arguments passed to the
       ;; vararg parameter.  FIXME... After Valhalla, revise this to
       ;; check type of vararg arguments as well?
       (consume-args acc argv ptypes (dec (alength ptypes)) vararg-tp)
       (consume-args acc argv ptypes Integer/MAX_VALUE jb/Object))))
  (^IPersistentVector [^IPersistentVector acc
                       ^IPersistentVector argv
                       ^Class* ptypes
                       ^int vararg-start ^Class vararg-tp]
   (loop [acc acc, i 0]
     (if (= i (count argv))
       acc
       (recur (conj acc (if (>= i vararg-start)
                          (-> (conv/consume-poly (nth argv i))
                              (tp/coerce-vararg vararg-tp))
                          (conv/consume (nth argv i) (aget ptypes i) "parameter")))
              (inc i))))))

(letfn [(argument-types ^Class* [^IPersistentVector argv ^boolean static?]
          (let [offset (if static? 0 1)
                a (new Class* (- (count argv) offset))]
            (dotimes [i (alength a)]
              (aset a i (x/type (nth argv (+ i offset)))))
            a))
        (settable? ^boolean [^Field f]
          (not (Modifier/isFinal (.getModifiers f))))

        (method-descriptor ^String [^Method m]
          (-> (rt/mtd-of (.getReturnType m) (.getParameterTypes m))
              (.descriptorString)))
        (invoke-method* ^Expr [^long x-env ^DirectMethodHandleDesc$Kind k
                               ^ClassDesc owner ^Method m
                               ^IPersistentVector argv]
          (let [mhd (MethodHandleDesc/of k owner (.getName m)
                                         (method-descriptor m))]
            (x/invoke-xref x-env (.getReturnType m) argv nil mhd false)))
        (invoke-method ^Expr [^long x-env ^DirectMethodHandleDesc$Kind k
                              ^ClassDesc owner ^Method m
                              ^Class* atypes ^IPersistentVector argv]
          (cond
            (signature-polymorphic? m)
            (x/invoke-poly x-env jb/cl-polymorphic-type argv nil k
                           owner (.getName m) (.isInterface k))

            (invoke-via-method-handle? m atypes)
            (x/mh-invoke-xref x-env (.getReturnType m) argv nil k
                              owner (.getName m) (method-descriptor m))

            :else
            (invoke-method* x-env k owner m argv)))

        (constr-descriptor ^String [^Constructor c]
          (-> (rt/mtd-of rt/void (.getParameterTypes c))
              (.descriptorString)))
        (invoke-constr* ^Expr [^long x-env ^Class owner ^Constructor c
                               ^IPersistentVector argv]
          (let [mhd (MethodHandleDesc/of rt/mhk-constructor
                                         (rt/describe-class owner)
                                         ConstantDescs/INIT_NAME
                                         (constr-descriptor c))]
            (x/invoke-xref x-env owner argv nil mhd false)))
        (invoke-constr ^Expr [^long x-env ^Class owner ^Constructor c
                              ^Class* atypes ^IPersistentVector argv]
          (if (invoke-via-method-handle? c atypes)
            (x/mh-invoke-xref x-env owner argv nil rt/mhk-constructor
                              (rt/describe-class owner) ConstantDescs/INIT_NAME
                              (constr-descriptor c))
            (invoke-constr* x-env owner c argv)))]
  
  (defn invoke-as-member ^Expr [^long x-env ^Class owner ^String nm
                                ^IPersistentVector argv ^boolean static?]
    ;; note: `atypes` of virtual methods and fields omits argv[0]
    (let [atypes (argument-types argv static?)
          fields-only? (.startsWith nm "-")
          nm (cond-> nm fields-only? (.substring 1))
          owner-cd (if (jb/array? owner) rt/object (rt/describe-class owner))
          k (rt/method-kind owner static?)]
      
      (letfn [(wrong [ms]
                (wrong-member ms
                              (str (if static? "static" "virtual")
                                   (cond fields-only? " field"
                                         (pos? (alength atypes)) " method"
                                         :else " member"))
                              owner nm atypes))
          
              (load-field []
                (try
                  (let [f (.getField owner nm)]
                    (if (and (= (Modifier/isStatic (.getModifiers f)) static?)
                             (zero? (alength atypes)))
                      (let [mhd (MethodHandleDesc/ofField
                                 (if static? rt/mhk-static-getter rt/mhk-getter)
                                 (rt/describe-class owner) (.getName f)
                                 (rt/cd-of (.getType f)))]
                        (x/invoke-xref x-env (.getType f) argv nil mhd
                                       (settable? f)))
                      (wrong ())))
                  (catch NoSuchFieldException _
                    (wrong ()))))]
        
        (if fields-only?
          (load-field)
          (if-some [m (method-exact static? owner nm atypes)]
            (invoke-method* x-env k owner-cd m argv)
            ;; `atypes` does not include receiver, but the receiver is
            ;; counted as an implicit invocation argument
            (if-some [ms (seq (->> (methods-with static? owner nm atypes)
                                   (dominating-alignments)))]
              (if-some [m ^Method (pick-member ms)]
                (->> (if static?
                       (consume-args [] argv m)
                       (consume-args (subvec argv 0 1) (subvec argv 1) m))
                     (invoke-method x-env k owner-cd m atypes))
                (wrong ms))
              (load-field)))))))

  (defn invoke-as-constructor ^Expr [^long x-env ^Class owner
                                     ^IPersistentVector argv]
    (let [nm ConstantDescs/INIT_NAME
          atypes (argument-types argv true)]
      (if-some [c (constructor-exact owner atypes)]
        (invoke-constr* x-env owner c argv)
        (let [cs (->> (constructors-with owner atypes)
                      (dominating-alignments))]
          (if-some [c ^Constructor (pick-member cs)]
            (->> (consume-args [] argv c)
                 (invoke-constr x-env owner c atypes))
            (wrong-member cs "constructor" owner nm atypes)))))))

;;; ------------------------------------------------------------------------

(letfn [(vp? ^boolean [^Method m]
          (let [mods (.getModifiers m)]
            (and (not (Modifier/isStatic mods))
                 (Modifier/isProtected mods)
                 (not (.isBridge m)))))
        (protected-methods [^Class cl]
          (when (some? cl)
            (lazy-seq
             (concat (filter vp? (.getDeclaredMethods cl))
                     (protected-methods (.getSuperclass cl))))))
        (vpp? ^boolean [^Method m]
          (let [mods (.getModifiers m)]
            (and (not (Modifier/isStatic mods))
                 (or (Modifier/isPublic mods) (Modifier/isProtected mods))
                 (not (.isBridge m)))))
        (public-or-protected-methods [^Class cl]
          (concat
           (filter vpp? (.getMethods cl)) ;all public methods (incl. inherited)
           (protected-methods cl))) ;protected methods from superclass chain

        ;; Picks up any matching virtual method, public *or*
        ;; protected.  Used to override protected method in reify*.
        (method-exact-pp ^Method [^Class owner ^String nm ^Class* ptypes]
          (->> (public-or-protected-methods owner)
               (filter (fn ^boolean [^Method m]
                         (and
                          (= (.getName m) nm)
                          (Arrays/equals (.getParameterTypes m) ptypes))))
               (first)))

        (drop-equal-parameters [ms]
          ;; get rid of any matches with different owners by equal
          ;; parameter types, like
          ;; (.containsKey ^boolean [clojure.lang.Associative Object]
          ;; (.containsKey ^boolean [java.util.Map Object]
          (if (next ms)
            (let [m ^Method (first ms)
                  pred (fn ^boolean [^Method o]
                         (and (= (.isVarArgs m) (.isVarArgs o))
                              (Arrays/equals (.getParameterTypes m)
                                             (.getParameterTypes o))))]
              (cons m (lazy-seq (->> (remove pred (rest ms))
                                     (drop-equal-parameters)))))
            ms))]
  
  ;; Picks up public or protected virtual method.
  (defn itf-methods-with-name [^Class owner ^String nm ^int arity]
    (->> (public-or-protected-methods owner)
         (filter (fn ^boolean [^Method m]
                   (and (= nm (.getName m))
                        (= arity (.getParameterCount m)))))
         (filter-dominators)
         (drop-equal-parameters)))

  ;; If `return-type` is not cl-polymorphic-type, then it must match
  ;; the the return type of the method.
  (defn itf-method-exact ^Method [^Class owner ^String nm ^Class return-type
                                  ^Class* atypes]
    (when-some [^Method m (or (method-exact false owner nm atypes)
                              (method-exact-pp owner nm atypes))]
      (when (or (jb/polymorphic? return-type)
                (jb/same-class? (.getReturnType m) return-type))
        m))))

(letfn [(functional-itf? ^boolean [^Class cl]
          (some? (.getAnnotation cl java.lang.FunctionalInterface)))
        (object-method? ^boolean [^Method m]
          (try
            (let [m* (.getMethod Object (.getName m) (.getParameterTypes m))]
              (and (jb/same-class? (.getReturnType m) (.getReturnType m*))
                   (= (.isVarArgs m) (.isVarArgs m*))))
            (catch NoSuchMethodException _
              false)))
        (abstract-method? ^boolean [^Method m]
          (Modifier/isAbstract (.getModifiers m)))]
  (defn itf-methods [^Class itf]
    (let [ms (.getDeclaredMethods itf)]
      (if (functional-itf? itf)
        (let [abs-ms (->> (filter abstract-method? ms)
                          (remove object-method?))]
          (assert (= (count abs-ms) 1))
          abs-ms)
        (filter abstract-method? ms)))))
