;; Copyright (c) Michael van Acken. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 2.0 (https://www.eclipse.org/legal/epl-v20.html)
;; which can be found in the file epl-v20.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.
(ns tcljc.compiler.resolve
  (:require
   [tcljc.javabase :as jb]
   [tcljc.runtime :as rt]
   [tcljc.wrong :as wrong]
   [tcljc.expr :as x]
   [tcljc.type :as tp]
   [tcljc.compiler.conv :as conv])
  (:import
   (tcljc.expr Expr InvokeXref)
   (clojure.lang IPersistentVector)
   (java.lang.constant MethodHandleDesc ConstantDescs
                       ClassDesc DirectMethodHandleDesc$Kind)
   (java.lang.reflect Executable Field Method Constructor Modifier)
   (java.util Arrays)))

(defn- assignable-to? ^boolean [^Class from-tp ^Class to-tp]
  (cond
    (identical? to-tp from-tp)
    true

    (or (jb/primitive? to-tp) (jb/primitive? from-tp))
    (tp/adaptable-to? from-tp to-tp)

    (and (jb/reference? to-tp) (jb/object? from-tp))
    true
    
    :else (.isAssignableFrom to-tp from-tp)))


(defn- field-with ^Field [^boolean static? ^Class owner ^String nm]
  (try
    (let [f (.getField owner nm)]
      (when (= (Modifier/isStatic (.getModifiers f)) static?)
        f))
    (catch NoSuchFieldException _
      nil)))

(defn- invocation-parameter-count ^int [^Executable e]
  (cond-> (.getParameterCount e)
    (and (instance? Method e)           ;exclude Constructor
         (not (Modifier/isStatic (.getModifiers e))))
    (inc)))                      ;receiver is passed as extra argument

(letfn [(parameter-count-match? ^boolean [^int arg-count ^Executable e]
          (let [n (invocation-parameter-count e)]
            (or (= n arg-count)
                (and (.isVarArgs e) (>= arg-count (dec n))))))]

  (defn method-exact ^Method [^boolean static? ^Class owner ^String nm
                              ^Class* atypes]
    (letfn [(match-static ^Method [^Method m]
              (when (= (Modifier/isStatic (.getModifiers m)) static?)
                m))]
      (try
        (match-static (.getMethod owner nm atypes))
        (catch NoSuchMethodException _
          (when (jb/interface? owner)
            (try ;if owner is an interface, then try again with Object
              (match-static (.getMethod Object nm atypes))
              (catch NoSuchMethodException _
                nil)))))))
  
  (defn methods-with [^boolean static? ^Class owner ^String nm ^int arg-count]
    (filter (fn ^boolean [^Method m]
              (and (= nm (.getName m))
                   (= (Modifier/isStatic (.getModifiers m)) static?)
                   (parameter-count-match? arg-count m)
                   (not (.isBridge m))))
            (.getMethods owner)))

  (defn constructor-exact ^Constructor [^Class owner ^Class* atypes]
    ;; returns nil if there is no exact match
    (try
      (.getConstructor owner atypes)
      (catch NoSuchMethodException _
        nil)))
  
  (defn constructors-with [^Class owner ^int arg-count]
    (filter (fn ^boolean [^Constructor c]
              (parameter-count-match? arg-count c))
            (.getConstructors owner))))


(letfn [(settable? ^boolean [^Field f]  ;pre: `f` is public
          (not (Modifier/isFinal (.getModifiers f))))]

  (defn load-static ^Expr [^long x-env ^Class owner ^Field f
                           ^IPersistentVector argv]
    (let [mhd (MethodHandleDesc/ofField rt/mhk-static-getter
                                        (rt/describe-class owner) (.getName f)
                                        (rt/cd-of (.getType f)))]
      (x/invoke-xref x-env (.getType f) argv nil mhd (settable? f))))
  (defn static-field ^Field [^Class owner ^String nm ^Class* atypes]
    (when (zero? (alength atypes))
      (field-with true owner nm)))

  (defn load-virtual ^Expr [^long x-env ^Class owner ^Field f
                            ^IPersistentVector argv]
    (let [mhd (MethodHandleDesc/ofField rt/mhk-getter
                                        (rt/describe-class owner) (.getName f)
                                        (rt/cd-of (.getType f)))]
      (x/invoke-xref x-env (.getType f) argv nil mhd (settable? f))))
  (defn virtual-field ^Field [^Class owner ^String nm ^Class* atypes]
    (when (zero? (alength atypes))
      (field-with false owner nm))))

;;; Problem: class MethodHandle.PolymorphicSignature is not public
(def ^:private ann-polymorphic-signature
  (Class/forName "java.lang.invoke.MethodHandle$PolymorphicSignature"
                 false (ClassLoader/getPlatformClassLoader)))

(letfn [(compatible-prefix? ^boolean [^Class* atypes
                                      ^Class* ptypes
                                      ^int pdelta-end]
          (loop [i (+ (alength ptypes) pdelta-end)]
            (cond
              (neg? i) true
              (assignable-to? (aget atypes i) (aget ptypes i)) (recur (dec i))
              :else false)))
        (compatible-suffix? ^boolean [^Class* atypes
                                      ^Class ptype ^int start]
          (or (jb/object? ptype) ;FIXME... drop special case after Valhalla?
              (loop [i (dec (alength atypes))]
                (cond
                  (< i start) true
                  ;; FIXME... does this require special handling of
                  ;; primitives once the special case Object is gone?
                  (.isAssignableFrom ptype (aget atypes i)) (recur (dec i))
                  :else false))))
        
        (compatible-fix-args? ^boolean [^Class* atypes
                                        ^Class* ptypes]
          (and (= (alength atypes) (alength ptypes))
               (compatible-prefix? atypes ptypes -1)))
        (compatible-var-args? ^boolean [^Class* atypes
                                        ^Class* ptypes]
          (and (>= (alength atypes) (dec (alength ptypes)))
               (compatible-prefix? atypes ptypes -2)
               (let [va-tp (aget ptypes (dec (alength ptypes)))]
                 (compatible-suffix? atypes (.getComponentType va-tp)
                                     (dec (alength ptypes))))))
        (compatible-var-array? ^boolean [^Class* atypes
                                         ^Class* ptypes]
          (and (= (alength atypes) (alength ptypes))
               (.isAssignableFrom (aget ptypes (dec (alength ptypes)))
                                  (aget atypes (dec (alength atypes))))
               (compatible-prefix? atypes ptypes -2)))

        (signature-polymorphic* ^boolean [^Method m] ;pre: m.isVarArgs()
          (.isAnnotationPresent m ann-polymorphic-signature))]
  
  (defn signature-polymorphic? ^boolean [^Executable e] ;pre: e.isVarArgs()
    (and (instance? Method e) (signature-polymorphic* ^Method e)))
  
  (defn- compatible-args? ^boolean [^Class* atypes ^Executable e]
    (let [ptypes (.getParameterTypes e)]
      (if (.isVarArgs e)
        (or (compatible-var-args? atypes ptypes)
            (compatible-var-array? atypes ptypes)
            (signature-polymorphic? ^Method e))
        (compatible-fix-args? atypes ptypes))))
  
  (defn- filter-dominators [es]
    (letfn [(dominates-all? ^boolean [^Executable e]
              (every? #(compatible-args? (.getParameterTypes e) %) es))
            (filter-dominators* [es]
              (if (next es)
                (filter dominates-all? es)
                es))]
      (or (seq (filter-dominators* es)) es))))

(letfn [(method-descriptor ^String [^Method m]
          (-> (rt/mtd-of (.getReturnType m) (.getParameterTypes m))
              (.descriptorString)))

        (invoke-via-method-handle? ^boolean [^Executable e
                                             ^IPersistentVector argv]
          (and (.isVarArgs e)
               (or (not= (invocation-parameter-count e) (count argv))
                   (let [ptypes (.getParameterTypes e)
                         ptype (aget ptypes (dec (alength ptypes)))
                         atype (x/type (peek argv))]
                     (not (.isAssignableFrom ptype atype))))))]

  (defn- constr-descriptor ^String [^Constructor c]
    (-> (rt/mtd-of rt/void (.getParameterTypes c))
        (.descriptorString)))
  (defn- invoke-constr* ^Expr [^long x-env ^Class owner ^Constructor c
                               ^IPersistentVector argv]
    (let [mhd (MethodHandleDesc/of rt/mhk-constructor (rt/describe-class owner)
                                   ConstantDescs/INIT_NAME
                                   (constr-descriptor c))]
      (x/invoke-xref x-env owner argv nil mhd false)))
  (defn- invoke-constr ^Expr [^long x-env ^Class owner ^Constructor c
                              ^IPersistentVector argv]
    (if (invoke-via-method-handle? c argv)
      (x/mh-invoke-xref x-env owner argv nil rt/mhk-constructor
                        (rt/describe-class owner) ConstantDescs/INIT_NAME
                        (constr-descriptor c))
      (invoke-constr* x-env owner c argv)))

  (defn- mhk-static ^DirectMethodHandleDesc$Kind [^Class owner]
    (if (.isInterface owner)
      rt/mhk-interface-static
      rt/mhk-static))
  (defn- invoke-static* ^Expr [^long x-env ^Class owner ^Method m
                               ^IPersistentVector argv]
    (let [mhd (MethodHandleDesc/of (mhk-static owner) (rt/describe-class owner)
                                   (.getName m) (method-descriptor m))]
      (x/invoke-xref x-env (.getReturnType m) argv nil mhd false)))
  (defn- invoke-static ^Expr [^long x-env ^Class owner ^Method m
                              ^IPersistentVector argv]
    (cond
      (signature-polymorphic? m)
      (x/invoke-poly x-env jb/cl-polymorphic-type argv nil (mhk-static owner)
                     (rt/describe-class owner) (.getName m)
                     (.isInterface owner))

      (invoke-via-method-handle? m argv)
      (x/mh-invoke-xref x-env (.getReturnType m) argv nil (mhk-static owner)
                        (rt/describe-class owner) (.getName m)
                        (method-descriptor m))

      :else
      (invoke-static* x-env owner m argv)))

  (defn- mhk-virtual ^DirectMethodHandleDesc$Kind [^Class owner]
    (if (.isInterface owner)
      rt/mhk-interface-virtual
      rt/mhk-virtual))
  (defn- owner-cd-virtual ^ClassDesc [^Class owner]
    (if (jb/array? owner)
      rt/object
      (rt/describe-class owner)))
  (defn- invoke-virtual* ^Expr [^long x-env ^Class owner ^Method m
                                ^IPersistentVector argv]
    (let [mhd (MethodHandleDesc/of (mhk-virtual owner) (owner-cd-virtual owner)
                                   (.getName m) (method-descriptor m))]
      (x/invoke-xref x-env (.getReturnType m) argv nil mhd false)))
  (defn- invoke-virtual ^Expr [^long x-env ^Class owner ^Method m
                               ^IPersistentVector argv]
    (cond
      (signature-polymorphic? m)
      (x/invoke-poly x-env jb/cl-polymorphic-type argv nil (mhk-virtual owner)
                     (owner-cd-virtual owner) (.getName m) (.isInterface owner))

      (invoke-via-method-handle? m argv)
      (x/mh-invoke-xref x-env (.getReturnType m) argv nil (mhk-virtual owner)
                        (owner-cd-virtual owner) (.getName m)
                        (method-descriptor m))

      :else
      (invoke-virtual* x-env owner m argv))))

;;; ------------------------------------------------------------------------

(defn- argument-types ^Class* [^IPersistentVector argv]
  (let [a (new Class* (count argv))]
    (dotimes [i (alength a)]
      (aset a i (x/type (nth argv i))))
    a))

(defn- pick-member [members]
  (when (nil? (next members))
    (first members)))
(defn- wrong-member [members ^String member-label ^Class owner ^String nm
                     ^Class* atypes]
  (letfn [(invoke-ex-data []
            {:invoke/name nm
             :invoke/owner owner
             :invoke/arg-types atypes})]
    (if-some [ms (seq members)]
      (-> (str "multiple " member-label "s matching ")
          (wrong/unresolved-interop nm owner (invoke-ex-data)))
      (-> (str "no " member-label " matching ")
          (wrong/unresolved-interop nm owner (invoke-ex-data))))))


;;; Returns component type of the varargs parameter, or nil if no
;;; arguments are collected into an array.  If `e` is polymorphic,
;;; result is always `cl-polymorphic-type`.
(defn- collecting-vararg-type ^Class [^Executable e ^IPersistentVector argv]
  (when (.isVarArgs e)
    (if (signature-polymorphic? e)
      jb/cl-polymorphic-type
      (let [n (.getParameterCount e)
            va-param-tp (aget (.getParameterTypes e) (dec n))]
        (if (and (= n (count argv))
                 (.isAssignableFrom va-param-tp (x/type (peek argv))))
          nil                           ;array already provided
          (.componentType va-param-tp))))))

(defn- consume-args
  (^IPersistentVector [^IPersistentVector acc
                       ^IPersistentVector argv
                       ^Executable e]
   (let [ptypes (.getParameterTypes e)]
     (if-some [vararg-tp (collecting-vararg-type e argv)]
       ;; For a polymorphic method, skip adapting of arguments
       ;; starting with the position of the vararg parameter.  For a
       ;; varargs method, only adapt reference arguments passed to the
       ;; vararg parameter.  FIXME... After Valhalla, revise this to
       ;; check type of vararg arguments as well?
       (consume-args acc argv ptypes (dec (alength ptypes)) vararg-tp)
       (consume-args acc argv ptypes Integer/MAX_VALUE jb/Object))))
  (^IPersistentVector [^IPersistentVector acc
                       ^IPersistentVector argv
                       ^Class* ptypes
                       ^int vararg-start ^Class vararg-tp]
   (loop [acc acc, i 0]
     (if (= i (count argv))
       acc
       (recur (conj acc (if (>= i vararg-start)
                          (-> (conv/consume-poly (nth argv i))
                              (tp/coerce-vararg vararg-tp))
                          (conv/consume (nth argv i) (aget ptypes i) "parameter")))
              (inc i))))))

(defn invoke-as-static ^Expr [^long x-env ^Class owner ^String nm
                              ^IPersistentVector argv]
  (let [atypes (argument-types argv)
        fields-only? (.startsWith nm "-")
        nm (cond-> nm fields-only? (.substring 1))
        argv-prefix []
        wrong (fn [ms]
                (wrong-member ms (cond fields-only? "static field"
                                       (pos? (alength atypes)) "static method"
                                       :else "static member")
                              owner nm atypes))
        load-field (fn []
                     (if-some [f (static-field owner nm atypes)]
                       (load-static x-env owner f argv-prefix)
                       (wrong ())))]
    (if fields-only?
      (load-field)
      (if-some [m (method-exact true owner nm atypes)]
        (invoke-static* x-env owner m argv)
        (if-some [ms (seq (->> (methods-with true owner nm (alength atypes))
                               (filter #(compatible-args? atypes %))
                               (filter-dominators)))]
          (if-some [m ^Method (pick-member ms)]
            (->> (consume-args argv-prefix argv m)
                 (invoke-static x-env owner m))
            (wrong ms))
          (load-field))))))

(defn invoke-as-virtual ^Expr [^long x-env ^Expr inst ^String nm
                               ^IPersistentVector argv]
  (let [atypes (argument-types argv)
        fields-only? (.startsWith nm "-")
        nm (cond-> nm fields-only? (.substring 1))
        owner (x/type inst)
        argv-prefix [inst]
        wrong (fn [ms]
                (wrong-member ms (cond fields-only? "virtual field"
                                       (pos? (alength atypes)) "virtual method"
                                       :else "virtual member")
                              owner nm atypes))
        load-field (fn []
                     (if-some [f (virtual-field owner nm atypes)]
                       (load-virtual x-env owner f argv-prefix)
                       (wrong ())))]
    (if fields-only?
      (load-field)
      (if-some [m (method-exact false owner nm atypes)]
        (invoke-virtual* x-env owner m (into argv-prefix argv))
        ;; `atypes` does not include receiver, but the receiver is
        ;; counted as an implicit invocation argument
        (if-some [ms (seq (->> (methods-with false owner nm
                                             (inc (alength atypes)))
                               (filter #(compatible-args? atypes %))
                               (filter-dominators)))]
          (if-some [m ^Method (pick-member ms)]
            (->> (consume-args argv-prefix argv m)
                 (invoke-virtual x-env owner m))
            (wrong ms))
          (load-field))))))

(defn invoke-as-constructor ^Expr [^long x-env ^Class owner
                                   ^IPersistentVector argv]
  (let [nm ConstantDescs/INIT_NAME
        atypes (argument-types argv)]
    (if-some [c (constructor-exact owner atypes)]
      (invoke-constr* x-env owner c argv)
      (let [cs (->> (constructors-with owner (alength atypes))
                    (filter #(compatible-args? atypes %))
                    (filter-dominators))]
        (if-some [c ^Constructor (pick-member cs)]
          (->> (consume-args [] argv c)
               (invoke-constr x-env owner c))
          (wrong-member cs "constructor" owner nm atypes))))))

;;; ------------------------------------------------------------------------

(letfn [(vp? ^boolean [^Method m]
          (let [mods (.getModifiers m)]
            (and (not (Modifier/isStatic mods))
                 (Modifier/isProtected mods)
                 (not (.isBridge m)))))
        (protected-methods [^Class cl]
          (when (some? cl)
            (lazy-seq
             (concat (filter vp? (.getDeclaredMethods cl))
                     (protected-methods (.getSuperclass cl))))))
        (vpp? ^boolean [^Method m]
          (let [mods (.getModifiers m)]
            (and (not (Modifier/isStatic mods))
                 (or (Modifier/isPublic mods) (Modifier/isProtected mods))
                 (not (.isBridge m)))))
        (public-or-protected-methods [^Class cl]
          (concat
           (filter vpp? (.getMethods cl)) ;all public methods (incl. inherited)
           (protected-methods cl))) ;protected methods from superclass chain

        ;; Picks up any matching virtual method, public *or*
        ;; protected.  Used to override protected method in reify*.
        (method-exact-pp ^Method [^Class owner ^String nm ^Class* ptypes]
          (->> (public-or-protected-methods owner)
               (filter (fn ^boolean [^Method m]
                         (and
                          (= (.getName m) nm)
                          (Arrays/equals (.getParameterTypes m) ptypes))))
               (first)))

        (drop-equal-parameters [ms]
          ;; get rid of any matches with different owners by equal
          ;; parameter types, like
          ;; (.containsKey ^boolean [clojure.lang.Associative Object]
          ;; (.containsKey ^boolean [java.util.Map Object]
          (if (next ms)
            (let [m ^Method (first ms)
                  pred (fn ^boolean [^Method o]
                         (and (= (.isVarArgs m) (.isVarArgs o))
                              (Arrays/equals (.getParameterTypes m)
                                             (.getParameterTypes o))))]
              (cons m (lazy-seq (->> (remove pred (rest ms))
                                     (drop-equal-parameters)))))
            ms))]
  
  ;; Picks up public or protected virtual method.
  (defn itf-methods-with-name [^Class owner ^String nm ^int arity]
    (->> (public-or-protected-methods owner)
         (filter (fn ^boolean [^Method m]
                   (and (= nm (.getName m))
                        (= arity (.getParameterCount m)))))
         (filter-dominators)
         (drop-equal-parameters)))

  ;; If `return-type` is not cl-polymorphic-type, then it must match
  ;; the the return type of the method.
  (defn itf-method-exact ^Method [^Class owner ^String nm ^Class return-type
                                  ^Class* atypes]
    (when-some [^Method m (or (method-exact false owner nm atypes)
                              (method-exact-pp owner nm atypes))]
      (when (or (jb/polymorphic? return-type)
                (jb/same-class? (.getReturnType m) return-type))
        m))))

(letfn [(functional-itf? ^boolean [^Class cl]
          (some? (.getAnnotation cl java.lang.FunctionalInterface)))
        (object-method? ^boolean [^Method m]
          (try
            (let [m* (.getMethod Object (.getName m) (.getParameterTypes m))]
              (and (jb/same-class? (.getReturnType m) (.getReturnType m*))
                   (= (.isVarArgs m) (.isVarArgs m*))))
            (catch NoSuchMethodException _
              false)))
        (abstract-method? ^boolean [^Method m]
          (Modifier/isAbstract (.getModifiers m)))]
  (defn itf-methods [^Class itf]
    (let [ms (.getDeclaredMethods itf)]
      (if (functional-itf? itf)
        (let [abs-ms (->> (filter abstract-method? ms)
                          (remove object-method?))]
          (assert (= (count abs-ms) 1))
          abs-ms)
        (filter abstract-method? ms)))))
