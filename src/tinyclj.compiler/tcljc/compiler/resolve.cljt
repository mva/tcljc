;; Copyright (c) Michael van Acken. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 2.0 (https://www.eclipse.org/legal/epl-v20.html)
;; which can be found in the file epl-v20.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.
(ns tcljc.compiler.resolve
  (:require
   [tcljc.javabase :as jb]
   [tcljc.runtime :as rt])
  (:import
   (java.lang.constant DirectMethodHandleDesc$Kind)
   (java.lang.reflect Method Member Modifier)
   (java.util Arrays)))

(def flag-static 0)
(def flag-virtual 1)
(def flag-field 2)
(def flag-method 3)

(def opts-virtual (bit-set 0 flag-virtual))
(def opts-static (bit-set 0 flag-static))

(let [mask-field (bit-set 0 flag-field)
      mask-method (bit-set 0 flag-method)
      mask-member (bit-or mask-field mask-method)]
  (defn fields-only? ^boolean [^int opts]
    (= mask-field (bit-and mask-member opts)))
  (defn methods-only? ^boolean [^int opts]
    (= mask-method (bit-and mask-member opts)))
  (defn static-virtual-match? ^boolean [^int opts ^Member m]
    (if (Modifier/isStatic (.getModifiers m))
      (bit-test opts flag-static)
      (bit-test opts flag-virtual))))

(defn first-argument-index ^int [^int opts] ;skips receiver
  (if (bit-test opts flag-virtual) 1 0))

(defn method-kind ^DirectMethodHandleDesc$Kind [^boolean static? ^Class owner]
  (if (.isInterface owner)
    (if static? rt/mhk-interface-static rt/mhk-interface-virtual)
    (if static? rt/mhk-static rt/mhk-virtual)))
(defn field-kind ^DirectMethodHandleDesc$Kind [^boolean static?]
  (if static? rt/mhk-static-getter rt/mhk-getter))


(defn method-exact ^Method [^int opts ^Class owner ^String nm ^Class* atypes]
  (letfn [(method-or-throw ^Method [^Class owner] ;throws NoSuchMethodException
            (let [m (.getMethod owner nm atypes)] ;works for class and array
              (when (static-virtual-match? opts m)
                m)))]
    (try
      (method-or-throw owner)
      (catch NoSuchMethodException _
        (when (jb/interface? owner)
          (try   ;if owner is an interface, then try again with Object
            (method-or-throw Object)
            (catch NoSuchMethodException _
              nil)))))))

;;; ------------------------------------------------------------------------

(letfn [(vp? ^boolean [^Method m]
          (let [mods (.getModifiers m)]
            (and (not (Modifier/isStatic mods))
                 (Modifier/isProtected mods)
                 (not (.isBridge m)))))
        (protected-methods [^Class cl]
          (when (some? cl)
            (lazy-seq
             (concat (filter vp? (.getDeclaredMethods cl))
                     (protected-methods (.getSuperclass cl))))))
        (vpp? ^boolean [^Method m]
          (let [mods (.getModifiers m)]
            (and (not (Modifier/isStatic mods))
                 (or (Modifier/isPublic mods) (Modifier/isProtected mods))
                 (not (.isBridge m)))))
        (public-or-protected-methods [^Class cl]
          (concat
           (filter vpp? (.getMethods cl)) ;all public methods (incl. inherited)
           (protected-methods cl))) ;protected methods from superclass chain

        ;; Picks up any matching virtual method, public *or*
        ;; protected.  Used to override protected method in reify*.
        (method-exact-pp ^Method [^Class owner ^String nm ^Class* ptypes]
          (->> (public-or-protected-methods owner)
               (filter (fn ^boolean [^Method m]
                         (and
                          (= (.getName m) nm)
                          (Arrays/equals (.getParameterTypes m) ptypes))))
               (first)))

        (drop-equal-parameters [ms]
          ;; get rid of any matches with different owners but equal
          ;; parameter types, like
          ;; (.containsKey ^boolean [clojure.lang.Associative Object]
          ;; (.containsKey ^boolean [java.util.Map Object]
          (if (next ms)
            (let [m ^Method (first ms)
                  pred (fn ^boolean [^Method o]
                         (and (= (.isVarArgs m) (.isVarArgs o))
                              (Arrays/equals (.getParameterTypes m)
                                             (.getParameterTypes o))))]
              (cons m (lazy-seq (->> (remove pred (rest ms))
                                     (drop-equal-parameters)))))
            ms))]
  
  ;; Picks up public or protected virtual method.
  (defn itf-methods-with-name [^Class owner ^String nm ^int arity]
    (->> (public-or-protected-methods owner)
         (filter (fn ^boolean [^Method m]
                   (and (= nm (.getName m))
                        (= arity (.getParameterCount m)))))
         (drop-equal-parameters)))

  ;; If `return-type` is not cl-polymorphic-type, then it must match
  ;; the the return type of the method.
  (defn itf-method-exact ^Method [^Class owner ^String nm ^Class return-type
                                  ^Class* atypes]
    (when-some [^Method m (or (method-exact opts-virtual owner nm atypes)
                              (method-exact-pp owner nm atypes))]
      (when (or (jb/polymorphic? return-type)
                (jb/same-class? (.getReturnType m) return-type))
        m))))

(letfn [(functional-itf? ^boolean [^Class cl]
          (some? (.getAnnotation cl java.lang.FunctionalInterface)))
        (object-method? ^boolean [^Method m]
          (try
            (let [m* (.getMethod Object (.getName m) (.getParameterTypes m))]
              (and (jb/same-class? (.getReturnType m) (.getReturnType m*))
                   (= (.isVarArgs m) (.isVarArgs m*))))
            (catch NoSuchMethodException _
              false)))
        (abstract-method? ^boolean [^Method m]
          (Modifier/isAbstract (.getModifiers m)))]
  (defn itf-methods [^Class itf]
    (let [ms (.getDeclaredMethods itf)]
      (if (functional-itf? itf)
        (let [abs-ms (->> (filter abstract-method? ms)
                          (remove object-method?))]
          (assert (= (count abs-ms) 1))
          abs-ms)
        (filter abstract-method? ms)))))
