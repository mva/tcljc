;; Copyright (c) Michael van Acken. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 2.0 (https://www.eclipse.org/legal/epl-v20.html)
;; which can be found in the file epl-v20.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.
(ns tcljc.emitter
  (:require
   [tcljc.config :as cfg]
   [tcljc.classfile :as cf]
   [tcljc.io :as io]
   [tcljc.javabase :as jb]
   [tcljc.runtime :as rt]
   [tcljc.wrong :as wrong]   
   [tcljc.context :as ctx]
   [tcljc.expr :as x]
   [tcljc.predefined :as predefined]
   [tcljc.publics :as publics]
   [tcljc.emitter.namespace :as nmsp]
   [tcljc.emitter.prepare :as prepare]
   [tcljc.emitter.bytecode :as bytecode]
   [tcljc.emitter.emitfn :as emitfn]
   [tcljc.emitter.classes :as classes]
   [tinyclj.string :as str])
  (:import
   (tcljc.classfile ClassDef)
   (tcljc.expr FnCode DeftypeDef MethodDef)
   (tcljc.io BuildIO NmspIO CompileIO)
   (tcljc.compiler DelayedMacroFn)
   (tcljc.emitter.namespace Namespace)
   (tcljc.emitter.emitfn FnSpec)
   (tcljc.emitter.prepare TopLevelForm)
   (tcljc.context FnRequireNamespace Ctx Msg)
   (tcljc.expr Expr Binding BindingRef FnForm)
   (clojure.lang ISeq IPersistentMap IPersistentVector ExceptionInfo)
   (jdk.incubator.concurrent StructuredTaskScope)
   (jdk.internal.classfile Classfile ClassBuilder CodeBuilder TypeKind)
   (java.lang.constant ClassDesc MethodTypeDesc ConstantDescs)
   (java.time Instant)
   (java.util Map HashMap HashSet ArrayDeque)
   (java.util.concurrent Future CompletableFuture ConcurrentHashMap
                         BlockingQueue)
   (java.util.function Consumer)))

(def first-segm-id 10)
(def capstone-class-name "___")
(def segment-class-prefix "_") ;followed by number: not parsed as symbol if empty


(deftype SegmState [^Ctx ctx
                    ^NmspIO nmsp-io
                    
                    ^int segm-id
                    ^ClassDesc segm-cld
                    ^IPersistentVector tlfv ;of TopLevelForm
                    ^ArrayDeque !delayed-macros ;shared across SegmState
                    
                    fn-class-futv])     ;vector of Future

(defn- segment-ns-str ^String [^SegmState segm]
  (-> segm .ctx .ns-str))
(defn- segment-name ^String [^SegmState segm ^int id-delta]
  (str (segment-ns-str segm) "." segment-class-prefix (+ (.segm-id segm) id-delta)))
(defn- segment-cld ^ClassDesc [^SegmState segm ^int id-delta]
  (if (zero? id-delta)
    (.segm-cld segm)
    (ClassDesc/of (segment-name segm id-delta))))

(defn with-tlf ^SegmState [^SegmState segm ^TopLevelForm tlf]
  (SegmState. (.ctx segm) (.nmsp-io segm)
              (.segm-id segm) (.segm-cld segm) (conj (.tlfv segm) tlf)
              (.!delayed-macros segm) (.fn-class-futv segm)))
(defn with-next-segm ^SegmState [^SegmState segm]
  (SegmState. (.ctx segm) (.nmsp-io segm)
              (inc (.segm-id segm)) (segment-cld segm +1)
              []                        ;clear tlfv
              (.!delayed-macros segm) (.fn-class-futv segm)))
(defn- with-fn-class-fut ^SegmState [^SegmState segm ^Future fut]
  (SegmState. (.ctx segm) (.nmsp-io segm)
              (.segm-id segm) (.segm-cld segm) (.tlfv segm)
              (.!delayed-macros segm) (conj (.fn-class-futv segm) fut)))
(defn- with-collect-fn-classes ^SegmState [^SegmState segm]
  (run! ctx/wait-for-result (.fn-class-futv segm))
  (SegmState. (.ctx segm) (.nmsp-io segm)
              (.segm-id segm) (.segm-cld segm) (.tlfv segm)
              (.!delayed-macros segm) []))

(defn- capstone-cld ^ClassDesc [^SegmState segm]
  (ClassDesc/of (-> segm .ctx .ns-str) capstone-class-name))

(defn with-force-clinit ^ClassBuilder [^ClassBuilder cb]
  ;; Static method with zero parameters, cannot clash with a regular
  ;; function's method name because of the suffix "~1".  Note: Could
  ;; also use requires~1 instead and drop its result.
  (.withMethodBody cb rt/name-force-clinit rt/mtd-void-void
                   (bit-or Classfile/ACC_PUBLIC Classfile/ACC_STATIC
                           Classfile/ACC_FINAL)
                   (cf/with-xbh [xb] (.return_ xb))))

(defn- builder-segment ^Consumer [^SegmState segm ^ClassDesc segm-cld
                                  ^boolean force-clinit?]
  (let [clinit (fn []
                 (let [ns-str (segment-ns-str segm)]
                   (-> []
                       (cond-> (= (.segm-id segm) first-segm-id)
                         (conj (x/invoke-xref
                                jb/void [(x/const String ns-str)]
                                rt/mhd-createNamespace)))
                       (into (map #(.top-level-form ^TopLevelForm %))
                             (.tlfv segm))
                       (cond-> (cfg/core-lib? ns-str)
                         (conj (x/invoke-xref
                                jb/void [(x/const String (segment-name segm 0))]
                                rt/mhd-markCoreInitialization)))
                       (x/progn*))))]
    (cf/with-cbh [cb]
      (when-not (= (.segm-id segm) first-segm-id)
        (.withSuperclass cb (segment-cld segm -1)))
      (doseq [^TopLevelForm tlf (.tlfv segm)]
        ;; emit fields and methods of all global bindings, delivering
        ;; their loads in order
        (doseq [^Binding global-b (.global-bs tlf)]
          (bytecode/emit-global-b cb segm-cld global-b))
        (doseq [^FnSpec fspec (.fn-specs tlf)]
          (.fn-methods (-> fspec .fn-form .!fnc .emit-plan) cb)))
      (-> (.withFlags cb Classfile/ACC_PUBLIC)
          (cond-> force-clinit? (with-force-clinit))
          (.withMethodBody ConstantDescs/CLASS_INIT_NAME rt/mtd-void-void
                           (bit-or Classfile/ACC_PUBLIC Classfile/ACC_STATIC)
                           (cf/with-xbh [xb]
                             (bytecode/emit-body xb (clinit))))))))

(defn with-main ^ClassBuilder [^ClassBuilder cb ^SegmState segm]
  (letfn [(main-function ^BindingRef []
            (let [globals (.get-globals (.ctx segm))]
              (when-some [bref (get globals "-main" nil)]
                (when (some? (x/root-fn-form bref))
                  bref))))]
    (when-some [bref (main-function)]
      (let [main-mtd (rt/mtd-of* rt/void (.arrayType rt/String))
            flags (bit-or Classfile/ACC_PUBLIC Classfile/ACC_STATIC
                          Classfile/ACC_FINAL)
            xbh (cf/with-xbh [xb]
                  (let [mtd (MethodTypeDesc/of rt/object rt/IFn rt/object)]
                    (-> (cf/ld-insn xb (x/deref-load bref))
                        (.aload 0)
                        (.invokestatic rt/RT "apply" mtd)
                        (.pop)
                        (.return_))))]
        (.withMethodBody cb "main" main-mtd flags xbh)))))

(defn- builder-capstone ^Consumer [^SegmState segm ^Namespace nmsp]
  (let [requires-xb (cf/with-xbh [xb]
                      (let [s (if (nmsp/core-lib? nmsp)
                                "" ;suppress internal details of core lib
                                (str/join "," (sort (.req-strs nmsp))))]
                        (-> xb (.constantInstruction s) (.areturn))))]
    (cf/with-cbh [cb]
      (-> (.withFlags cb Classfile/ACC_PUBLIC)
          (.withSuperclass (segment-cld segm -1))
          (with-force-clinit)
          (.withMethodBody rt/name-requires rt/mtd-String-void
                           (bit-or Classfile/ACC_PUBLIC Classfile/ACC_STATIC
                                   Classfile/ACC_FINAL)
                           requires-xb)
          (with-main segm)))))

(defn- build-deftype ^ClassDef [^DeftypeDef dtdef]
  (letfn [(method-cbh [^MethodDef mdef]
            (cf/with-cbh [cb]
              (let [at (.at mdef)
                    this-class (-> dtdef .cdef .ch-info .thisClass)
                    ld-this (cf/ld-st-receiver this-class
                                               (name (.this-name at)))
                    xbh (cf/with-xbh [xb]
                          (.deliver-load (.this-bref mdef) ld-this)
                          (cf/st-insn xb ld-this true) ;emit LocalVariable entry
                          (bytecode/emit-body xb ld-this at 0
                                              (.body-expr mdef)))]
                (.withMethodBody cb (.method-name at) (x/at-mtd at)
                                 (.flags mdef) xbh))))]
    (let [cdef (.cdef dtdef)]
      (cf/with-methods cdef (map method-cbh (.method-defs dtdef))))))

(defn- mk-first-segm ^SegmState [^NmspIO nmsp-io ^Ctx ctx]
  (let [cld (ClassDesc/of (.ns-str ctx)
                          (str segment-class-prefix first-segm-id))]
    (SegmState. ctx nmsp-io first-segm-id cld [] (ArrayDeque.) [])))

(defn- emit-segments ^Namespace [^SegmState segm
                                 ^StructuredTaskScope nmsp-task-scope]
  (letfn [(take-msg ^Msg [^BlockingQueue q]
            (.take q))
          (schedule-fn-class ^SegmState [^SegmState segm ^FnCode fnc]
            (if-some [cbh (.fn-cbh (.emit-plan fnc))]
              (with-fn-class-fut segm
                (.fork-task (.nmsp-io segm) nmsp-task-scope
                            (^Callable fn []
                             (.produce-class (.nmsp-io segm)
                                             ^ClassDesc (.ld-clx fnc) cbh))
                            cfg/fork-work?))
              segm))
          (schedule-fn-classes ^SegmState [^SegmState segm ^TopLevelForm tlf]
            (let [segm (with-tlf segm tlf)
                  fncs (map #(-> ^FnSpec % .fn-form .!fnc) (.fn-specs tlf))]
              (doseq [^FnCode fnc fncs :let [ep (.emit-plan fnc)]]
                (when-some [ch-info (.fn-class-hierarchy-info ep)]
                  (.register-ch-info! (.nmsp-io segm) ch-info)))
              (reduce schedule-fn-class segm fncs)))
          (delayed-but-ready ^DelayedMacroFn [^SegmState segm]
            (when-some [mfn ^DelayedMacroFn (.peekFirst (.!delayed-macros segm))]
              (when (.realized? (.bref mfn))
                mfn)))
          (load-bref ^Object [^CompileIO compile-io ^BindingRef bref]
            (.invoke-global-mh compile-io
                               (.mh-if-global (x/deref-load bref)
                                              (.lookup-in-pkg compile-io))))
          (write-segment ^SegmState [^SegmState segm ^boolean force-clinit?]
            (if (and (not force-clinit?) (zero? (count (.tlfv segm))))
              segm                    ;nothing to do for empty segment
              ;; Note: There is no point to move the segment class into
              ;; a future, because it is immediately required -- either
              ;; for a macro value or for namespace completion.
              (let [segm-cld (segment-cld segm 0)
                    cbh (builder-segment segm segm-cld force-clinit?)
                    ;; macros from this segment class can be invoked
                    ;; once it is defined: make sure there are no
                    ;; pending dependencies
                    segm (with-collect-fn-classes segm)
                    cbd (.produce-class (.nmsp-io segm) segm-cld cbh)]
                (loop []
                  (when-some [mfn (delayed-but-ready segm)]
                    (when-not (.complete (.value-promise mfn)
                                         (load-bref (-> segm .ctx .compile-io)
                                                    (.bref mfn)))
                      (throw (IllegalStateException.)))
                    (.removeFirst (.!delayed-macros segm))
                    (recur)))
                (with-next-segm segm))))
          (write-and-define ^SegmState [^SegmState segm ^ClassDef cdef
                                        ^CompletableFuture promise]
            (.register-ch-info! (.nmsp-io segm) (.ch-info cdef))
            (let [cbh (cf/with-cbh [cb]
                        (-> (.withFlags cb (.flags cdef))
                            (.withSuperclass (-> cdef .ch-info .superClass))
                            (.withInterfaceSymbols (.itfs cdef)))
                        (run! #(.accept ^Consumer % cb) (.cb-handlerv cdef)))
                  this-class (-> cdef .ch-info .thisClass)
                  cl (.produce-class (.nmsp-io segm) this-class cbh)]
              (.complete promise cl)
              segm))
          (write-capstone ^Namespace [^SegmState segm ^Namespace nmsp]
            (nmsp/with-capstone nmsp
              (.produce-class (.nmsp-io segm) (capstone-cld segm)
                              (builder-capstone segm nmsp))))
          
          (fn-specs-from-methods ^IPersistentVector [mdefs ^SegmState segm]
            (reduce
             (fn collect-fn-specs [acc ^MethodDef mdef]
               (let [body (.body-expr mdef)
                     tlf (prepare/collect-fn-info body)]
                 (into acc (.fn-specs tlf))))
             [] mdefs))
          (complete-req! ^SegmState [^SegmState segm ^int task x
                                     ^CompletableFuture promise]
            (condp = task
              ctx/msg-emit-tlf
              (let [tlf (prepare/collect-fn-info x)]
                (prepare/prepare-fns! (.segm-cld segm) (.fn-specs tlf))
                (prepare/prepare-globals! (.segm-cld segm) (.global-bs tlf))
                (cond-> (schedule-fn-classes segm tlf)
                  (and (not (cfg/collect-macro-definitions?))
                       (some? (delayed-but-ready segm)))
                  (write-segment false)))

              ctx/msg-macro-of-next-tlf
              (do (.addLast (.!delayed-macros segm) x)
                  segm)

              ctx/msg-flush-macro-definitions
              (do (assert (cfg/collect-macro-definitions?))
                  (cond-> segm
                    (delayed-but-ready segm) (write-segment false)))
              
              ctx/req-define-class
              (if (instance? ClassDef x)
                (write-and-define segm ^ClassDef x promise)
                (let [dtdef ^DeftypeDef x
                      fn-specs (fn-specs-from-methods (.method-defs dtdef) segm)
                      tlf (TopLevelForm. fn-specs nil x/expr-empty)]
                  (prepare/prepare-fns! (.segm-cld segm) fn-specs)
                  (-> (schedule-fn-classes segm tlf)
                      (write-and-define (build-deftype dtdef) promise))))
              
              ctx/req-flush-namespace-segment
              (let [cl (write-segment segm true)]
                ;; segment class `cl` exists and can now be looked up
                (.complete promise (x/invoke-force-clinit (.segm-cld segm)))
                cl)
              
              ctx/msg-fatal-error
              (throw ^Throwable x)
              
              #_else (throw (IllegalStateException. (str task)))))]

    (let [msg (take-msg (-> segm .ctx .emit-q))]
      (if (= (.task msg) ctx/msg-close-queue)
        (-> segm (write-segment false) (write-capstone (.x msg)))
        (recur (complete-req! segm (.task msg) (.x msg) (.promise msg))
               nmsp-task-scope)))))

(defn mk-provided-nmsp
  ([]
   (reduce-kv nmsp/assoc-provided {} predefined/implicit-known-ns))
  ([^String ns-str ^IPersistentMap publics]
   (nmsp/assoc-provided (mk-provided-nmsp) ns-str publics)))

(defn- init-known-ns ^void [^Ctx ctx ^IPersistentMap provided-nmsp]
  (doseq [[ns-str nmsp] provided-nmsp]
    (assert (string? ns-str))
    (assert (instance? Namespace nmsp)))
  (let [primitive-publics (-> (get provided-nmsp cfg/primitive-ns-str)
                              (nmsp/publics-of cfg/primitive-ns-str))]
    (doto ctx
      ;; primitive namespace can be used without require-ing it
      (.merge-into-known-ns {cfg/primitive-ns-str primitive-publics})
      (.put-ns-alias cfg/primitive-ns-str cfg/primitive-ns-str))))

;; Writes this namespace's bytecode to class files.  Assumes that
;; somewhere up in the call chain (i.e. tclj0 or tclj1) any classes in
;; this namespace's output package directory have been deleted.  The
;; output directory is created if it does not exist.
;;
;; Note: Exceptions are reported in the order in which they occur in
;; the emitter thread.  The "compile namespace" thread can fork of an
;; arbitrary number of futures of its own, and the emitter retrieves
;; their result/exception in emit order.
(defn- emit-namespace ^Namespace [^SegmState segm ^IPersistentMap provided-nmsp
                                  ^HashSet !rpath-set
                                  ^StructuredTaskScope nmsp-task-scope]
  (let [ctx (.ctx segm)]
    (init-known-ns ctx provided-nmsp)
    
    (let [c-fn (^Callable fn []
                (try
                  (let [nmsp (nmsp/mk-nmsp provided-nmsp !rpath-set ctx)
                        nmsp-io (.enter-source-file (.nmsp-io segm) (.ns-str ctx) true)
                        nsd (nmsp/compile-thread nmsp nmsp-io ctx)]
                    ;; regular completion: pass back result in first
                    ;; `close-queue` message
                    (ctx/send-msg (.emit-q ctx) ctx/msg-close-queue nsd))
                  (catch java.lang.InterruptedException _
                    ;; emitter thread is shutting down and is not taking
                    ;; any more messages: exit without sending anything
                    nil)
                  (catch Throwable t
                    (ctx/send-msg (.emit-q ctx) ctx/msg-fatal-error t))))
          c-thread (.fork-task (.nmsp-io segm) nmsp-task-scope c-fn true)
          nmsp (emit-segments segm nmsp-task-scope)]
      (.get c-thread)                   ;pick up any exceptions
      nmsp)))

;;; ------------------------------------------------------------------------

(letfn [(extract-req-strs ^"[Ljava.lang.String;" [^Class cl]
          (let [s (-> (.getDeclaredMethod cl rt/name-requires)
                      ^String (.invoke nil))]
            (if (= s "")
              (new "[Ljava.lang.String;" 0)
              (into-array String (str/split s #",")))))]
  (defn- import-from-capstone ^Namespace [^Namespace nmsp ^Class capstone]
    (init-known-ns (.ctx nmsp) (.provided-nmsp nmsp))
    
    ;; keep in sync with namespace/add-require-deps
    (let [ns-str (.getPackageName capstone)
          req-strs (extract-req-strs capstone)
          n (count req-strs)
          a (new objects n)
          apublics (new "[Lclojure.lang.IPersistentMap;" n)
          provide-nmsp (.provided-nmsp nmsp)]
      ;; schedule namespaces in parallel
      (dotimes [i n]
        (let [req-str (aget req-strs i)]
          (aset a i (or (get (.provided-nmsp nmsp) req-str)
                        (-> (.require-namespace (.ctx nmsp))
                            (.schedule req-str provide-nmsp))))))
      ;; wait for and pick up namespace outcomes
      (dotimes [i n]                    ;avoid stack frame spamming
        (let [ns-str (aget req-strs i)]
          (aset apublics i (-> (nmsp/nmsp-of (aget a i) ns-str)
                               (nmsp/publics-of ns-str)))))
      ;; collect all "require"d globals and then add any new globals
      ;; to this namespace
      (loop [publics-map {}, i 0]
        (if (= i n)
          (.merge-into-known-ns (.ctx nmsp) publics-map)
          (let [ns-str (aget req-strs i)
                ekns (.exported-known-ns (nmsp/nmsp-of (aget a i) ns-str))]
            (recur (merge publics-map ekns) (inc i)))))
      (nmsp/with-capstone nmsp capstone))))

;;; ------------------------------------------------------------------------

(defn mk-ctx ^Ctx [^BuildIO env
                   ^FnRequireNamespace require-namespace
                                 
                   ^IPersistentMap initial-globals
                   ^String ns-str
                   ^CompileIO compile-io
                                 
                   ^StructuredTaskScope arity-task-scope]
  (ctx/mk-ctx* initial-globals (.initial-imports env) ns-str compile-io
               require-namespace arity-task-scope))

(defn- mk-ctx-import ^Ctx [^BuildIO env
                           ^FnRequireNamespace require-namespace
                           ^Class capstone]
  (let [nmsp-io (.nmsp-io env capstone nil)]
    (ctx/mk-ctx* {} {} (.getPackageName capstone) (.compile-io nmsp-io)
                 require-namespace nil)))

(defn compile-and-emit ^Namespace [^BuildIO env ^String ns-str
                                   ^FnRequireNamespace require-fn
                                   ^IPersistentMap provided-nmsp
                                   ^IPersistentMap globals-override]
  (let [nmsp-task-scope (StructuredTaskScope.)
        !rpath-set (HashSet.)]
    (try
      (let [arity-task-scope (when-not cfg/deterministic-namespace-compile?
                               nmsp-task-scope)
            nmsp-io (.nmsp-io env ns-str !rpath-set)
            globals (or globals-override
                        (predefined/initial-globals-for (-> nmsp-io .compile-io .rt-lookup)
                                                        ns-str))
            tl-ctx (mk-ctx env require-fn globals ns-str (.compile-io nmsp-io)
                           arity-task-scope)]
        (-> (mk-first-segm nmsp-io tl-ctx)
            (emit-namespace provided-nmsp !rpath-set nmsp-task-scope)))
      (catch Throwable t
        (.shutdown nmsp-task-scope)     ;make join return immediately
        (throw t))
      (finally
        (.joinUntil nmsp-task-scope (-> (Instant/now) (.plusSeconds 5)))
        (.close nmsp-task-scope)))))

(defn- emit-namespaces-mt ^void [^BuildIO env ^IPersistentMap builtin-nmsp
                                 ns-strs ^StructuredTaskScope build-task-scope
                                 ^ConcurrentHashMap !futs]
  (let [namespaces-q (java.util.concurrent.LinkedBlockingQueue.)
        require-fn (^FnRequireNamespace fn [ns-str provided-nmsp]
                    (or
                     ;; First peek into the current namespace map, and
                     ;; return a known namespace immediately.
                     (.get !futs ns-str)
                     ;; For an unregistered namespace, delegate via message
                     ;; exchange/promise to the top-level thread's
                     ;; `namespace-loop`.
                     (let [cf (CompletableFuture.)]
                       (.put namespaces-q [ns-str provided-nmsp cf])
                       (ctx/wait-for-result 1 cf))))]
    (letfn [(fork-namespace ^Future [^String ns-str provided-nmsp]
              (->> (^Callable fn []
                    (or        ;import from dyn-ld or compile and emit
                     (when-some [cl (.try-load-capstone env ns-str)]
                       (try
                         (-> (nmsp/mk-imported provided-nmsp
                                               (mk-ctx-import env require-fn cl))
                             (import-from-capstone cl))
                         (finally ;signal completion to namespace loop
                           (.put namespaces-q [ns-str]))))
                  
                     (let [globals nil]
                       #_(prn :namespace-start ns-str)
                       (try
                         (compile-and-emit env ns-str require-fn
                                           provided-nmsp globals)
                         (finally ;signal completion to namespace loop
                           (.put namespaces-q [ns-str]))))))
                   (.fork-task env build-task-scope)))
            
            (fork-all! ^int [ns-strs] ;returns number of new namespaces
              ;; this thread owns !futs and there are no concurrent
              ;; updates; using size() is ok, and test followed by
              ;; put as well
              (let [n (.size !futs)]
                (doseq [ns-str ns-strs
                        :when (not (.containsKey !futs ns-str))
                        :let [fut (fork-namespace ns-str builtin-nmsp)]]
                  (.put !futs ns-str fut))
                (- (.size !futs) n)))]
      
      ;; In the first phase, force discovery of core library.  Only
      ;; after it has completed handle all namespaces from `ns-strs`
      ;; -- until the new namespaces have completed as well.
      (loop [n (fork-all! [cfg/core-lib])] ;`n` counts in-progress tasks
        (if (zero? n)                ;all pending tasks have completed
          (let [d (fork-all! ns-strs)] ;(re-)add all top-level namespace tasks
            (when (pos? d)       ;exit loop if no new tasks were added
              (recur d)))
          (let [[^String ns-str provided-nmsp ^CompletableFuture cf] (.take namespaces-q)]
            (if (some? cf)
              (if-some [fut (.get !futs ns-str)]
                (do (.complete cf fut)
                    (recur n))
                (let [fut (fork-namespace ns-str provided-nmsp)]
                  (.put !futs ns-str fut)
                  (.complete cf fut)
                  (recur (inc n))))
              (do #_(prn :namespace-end ns-str)
                  (recur (dec n))))))))
    
    ;; If any namespace failed, then throw the first exception in
    ;; depth-first traversal order.  This should be deterministic,
    ;; even if there are errors in multiple namespaces and the
    ;; original exceptions are reported in arbitrary order.  It should
    ;; also report the same error in multi-threaded mode as in
    ;; single-threaded mode.
    (let [a ^"[Ljava.lang.String;" (into-array ns-strs)]
      ;; loop over array to avoid stack frame spamming
      (dotimes [i (alength a)]
        (ctx/get-result-now (.get !futs (aget a i))))))) ;forces exception

(defn- emit-namespaces-st ^void [^BuildIO env ^IPersistentMap builtin-nmsp
                                 ns-strs ^HashMap !futs]
  (let [require-fn
        (reify FnRequireNamespace
          (schedule [this ns-str provided-nmsp]
            (or (.get !futs ns-str)

                (when-some [cl (.try-load-capstone env ns-str)]
                  (.put !futs ns-str nmsp/marker-depth-first-path)
                  (let [x (-> (nmsp/mk-imported provided-nmsp
                                                (mk-ctx-import env this cl))
                              (import-from-capstone cl))]
                    (.put !futs ns-str x)
                    x))
                 
                (let [globals nil]
                  (.put !futs ns-str nmsp/marker-depth-first-path)
                  #_(prn :namespace-start ns-str)
                  (let [x (compile-and-emit env ns-str this
                                            provided-nmsp globals)]
                    #_(prn :namespace-end ns-str)
                    (.put !futs ns-str x)
                    x)))))]
    ;; first, force discovery of core library
    (.schedule require-fn cfg/core-lib builtin-nmsp)
    ;; then handle all namespaces from `ns-strs`
    (let [a ^"[Ljava.lang.String;" (into-array ns-strs)]
      ;; loop over array to avoid stack frame spamming
      (dotimes [i (alength a)]
        (.schedule require-fn (aget a i) builtin-nmsp)))))

;;; Returns a map of namespaces that have been reached by the build
;;; attempt.  Key is the name of the namespace (a string).  Value is a
;;; map {:rpaths :req-strs} for a compiled & completed namespace, nil
;;; if the namespace was not compiled successfully, and the empty map
;;; {} for a namespace imported from class files.
(defn dependency-map ^IPersistentMap [^Map futs]
  (letfn [(outcome-now [^Future x]
            (assert (.isDone x))
            (try (.get x) (catch Throwable t t)))
          (dependency-info [x]
            (cond
              (instance? Namespace x)
              (let [nmsp ^Namespace x]
                (if (nmsp/imported? nmsp)
                  {} ;rpaths and req-strs unchanged from prior compile
                  {:rpaths (into #{} (.!rpath-set nmsp))
                   :req-strs (.req-strs nmsp)}))

              (instance? Future x)
              (recur (outcome-now x))
              
              (or (instance? Throwable x)
                  (identical? nmsp/marker-depth-first-path x))
              nil     ;not completed successfully, assume to be broken
              
              :else (throw (IllegalArgumentException. (str (class x))))))
          (fixup-core-deps ^IPersistentMap [^IPersistentMap dep-map]
            (let [req-strs (get-in dep-map [cfg/core-lib :req-strs])]
              (cond-> dep-map
                (seq req-strs)    ;any recorded dependencies for core?
                (assoc cfg/core-lib
                       {:rpaths (into (get-in dep-map [cfg/core-lib :rpaths])
                                      (mapcat #(get-in dep-map [% :rpaths]))
                                      req-strs)
                        :req-strs #{}}))))]
    (-> (reduce-kv #(assoc %1 %2 (dependency-info %3)) {} futs)
        (fixup-core-deps))))
(defn completed-namespace? ^boolean [^IPersistentMap dependency-info]
  (some? dependency-info))
(defn imported-namespace? ^boolean [^IPersistentMap dependency-info]
  (= dependency-info {}))               ;implies completed-namespace?


;;; Builtin namespaces in `builtin-nmsp` can be required directly from
;;; any namespace (maps string -> Namespace).
;;; 
;;; On success, returns map String -> Namespace of all namespaces.
;;; Any compilation error causes an ExceptionInfo exception whose
;;; entry :emitter/namespaces is a dependency map.
(defn emit-namespaces ^IPersistentMap [^BuildIO env ^IPersistentMap builtin-nmsp
                                       ns-strs]
  (letfn [(assoc-namespaces ^ExceptionInfo [^Throwable t ^Map futs]
            (wrong/assoc-dep-map t (dependency-map futs)))]
    (if cfg/deterministic-namespace-compile?
      (let [!futs (java.util.HashMap.)] ;single-threaded!
        (try
          (emit-namespaces-st env builtin-nmsp ns-strs !futs)
          (into {} !futs)
          (catch Throwable t
            (throw (assoc-namespaces t !futs)))))
      (let [!futs (ConcurrentHashMap.)  ;updated by this thread only
            build-task-scope (StructuredTaskScope.)]
        (try
          (emit-namespaces-mt env builtin-nmsp ns-strs build-task-scope !futs)
          (into {} !futs)
          (catch Throwable t
            (.shutdown build-task-scope) ;make join return immediately
            (throw (assoc-namespaces t !futs)))
          (finally
            (.joinUntil build-task-scope (-> (Instant/now) (.plusSeconds 5)))
            (.close build-task-scope)))))))
