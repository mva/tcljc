;; Copyright (c) Michael van Acken. All rights reserved.
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 2.0 (https://www.eclipse.org/legal/epl-v20.html)
;; which can be found in the file epl-v20.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.
(ns tcljc.emitter
  (:require
   [tcljc.config :as cfg]
   [tcljc.classfile :as cf]
   [tcljc.io :as io]
   [tcljc.javabase :as jb]
   [tcljc.runtime :as rt]
   [tcljc.wrong :as wrong]   
   [tcljc.context :as ctx]
   [tcljc.expr :as x]
   [tcljc.predefined :as predefined]
   [tcljc.emitter.namespace :as nmsp]
   [tcljc.emitter.prepare :as prepare]
   [tcljc.emitter.bytecode :as bytecode]
   [tcljc.emitter.emitfn :as emitfn]
   [tcljc.emitter.classes :as classes]
   [tinyclj.string :as str])
  (:import
   (tcljc.classfile ClassDef)
   (tcljc.expr FnCode DeftypeDef MethodDef)
   (tcljc.io BuildIO NmspIO CompileIO NmspBuilder)
   (tcljc.compiler DelayedMacroFn)
   (tcljc.emitter.namespace Namespace)
   (tcljc.emitter.emitfn FnSpec)
   (tcljc.emitter.prepare TopLevelForm)
   (tcljc.context Ctx Msg)
   (tcljc.expr Expr Binding BindingRef FnForm)
   (clojure.lang ISeq IPersistentMap IPersistentVector IPersistentSet
                 ExceptionInfo)
   (jdk.incubator.concurrent StructuredTaskScope)
   (jdk.internal.classfile Classfile ClassBuilder CodeBuilder TypeKind)
   (java.lang.constant ClassDesc MethodTypeDesc ConstantDescs)
   (java.time Instant)
   (java.util HashMap HashSet ArrayDeque)
   (java.util.concurrent Future CompletableFuture BlockingQueue)
   (java.util.function Consumer)))

(def first-segm-id 10)
(def capstone-class-name "___")
(def segment-class-prefix "_") ;followed by number: not parsed as symbol if empty


(deftype SegmState [^Ctx ctx
                    ^NmspIO nmsp-io
                    
                    ^int segm-id
                    ^ClassDesc segm-cld
                    ^IPersistentVector tlfv ;of TopLevelForm
                    ^ArrayDeque !delayed-macros ;shared across SegmState
                    
                    fn-class-futv])     ;vector of Future

(defn- segment-ns-str ^String [^SegmState segm]
  (-> segm .ctx .ns-str))
(defn- segment-name ^String [^SegmState segm ^int id-delta]
  (str (segment-ns-str segm) "." segment-class-prefix (+ (.segm-id segm) id-delta)))
(defn- segment-cld ^ClassDesc [^SegmState segm ^int id-delta]
  (if (zero? id-delta)
    (.segm-cld segm)
    (ClassDesc/of (segment-name segm id-delta))))

(defn with-tlf ^SegmState [^SegmState segm ^TopLevelForm tlf]
  (SegmState. (.ctx segm) (.nmsp-io segm)
              (.segm-id segm) (.segm-cld segm) (conj (.tlfv segm) tlf)
              (.!delayed-macros segm) (.fn-class-futv segm)))
(defn with-next-segm ^SegmState [^SegmState segm]
  (SegmState. (.ctx segm) (.nmsp-io segm)
              (inc (.segm-id segm)) (segment-cld segm +1)
              []                        ;clear tlfv
              (.!delayed-macros segm) (.fn-class-futv segm)))
(defn- with-fn-class-fut ^SegmState [^SegmState segm ^Future fut]
  (SegmState. (.ctx segm) (.nmsp-io segm)
              (.segm-id segm) (.segm-cld segm) (.tlfv segm)
              (.!delayed-macros segm) (conj (.fn-class-futv segm) fut)))
(defn- with-collect-fn-classes ^SegmState [^SegmState segm]
  (run! ctx/wait-for-result (.fn-class-futv segm))
  (SegmState. (.ctx segm) (.nmsp-io segm)
              (.segm-id segm) (.segm-cld segm) (.tlfv segm)
              (.!delayed-macros segm) []))

(defn- capstone-cld ^ClassDesc [^SegmState segm]
  (ClassDesc/of (-> segm .ctx .ns-str) capstone-class-name))

(defn with-force-clinit ^ClassBuilder [^ClassBuilder cb]
  ;; Static method with zero parameters, cannot clash with a regular
  ;; function's method name because of the suffix "~1".  Note: Could
  ;; also use requires~1 instead and drop its result.
  (.withMethodBody cb rt/name-force-clinit rt/mtd-void-void
                   (bit-or Classfile/ACC_PUBLIC Classfile/ACC_STATIC
                           Classfile/ACC_FINAL)
                   (cf/with-xbh [xb] (.return_ xb))))

(defn- builder-segment ^Consumer [^SegmState segm ^ClassDesc segm-cld
                                  ^boolean force-clinit?]
  (let [clinit (fn []
                 (let [ns-str (segment-ns-str segm)]
                   (-> []
                       (cond-> (= (.segm-id segm) first-segm-id)
                         (conj (x/invoke-xref
                                jb/void [(x/const String ns-str)]
                                rt/mhd-createNamespace)))
                       (into (map #(.top-level-form ^TopLevelForm %))
                             (.tlfv segm))
                       (cond-> (cfg/core-lib? ns-str)
                         (conj (x/invoke-xref
                                jb/void [(x/const String (segment-name segm 0))]
                                rt/mhd-markCoreInitialization)))
                       (x/progn*))))]
    (cf/with-cbh [cb]
      (when-not (= (.segm-id segm) first-segm-id)
        (.withSuperclass cb (segment-cld segm -1)))
      (doseq [^TopLevelForm tlf (.tlfv segm)]
        ;; emit fields and methods of all global bindings, delivering
        ;; their loads in order
        (doseq [^Binding global-b (.global-bs tlf)]
          (bytecode/emit-global-b cb segm-cld global-b))
        (doseq [^FnSpec fspec (.fn-specs tlf)]
          (.fn-methods (-> fspec .fn-form .!fnc .emit-plan) cb)))
      (-> (.withFlags cb Classfile/ACC_PUBLIC)
          (cond-> force-clinit? (with-force-clinit))
          (.withMethodBody ConstantDescs/CLASS_INIT_NAME rt/mtd-void-void
                           (bit-or Classfile/ACC_PUBLIC Classfile/ACC_STATIC)
                           (cf/with-xbh [xb]
                             (bytecode/emit-body xb (clinit))))))))

(defn with-main ^ClassBuilder [^ClassBuilder cb ^SegmState segm]
  (letfn [(main-function ^BindingRef []
            (let [globals (.get-globals (.ctx segm))]
              (when-some [bref (get globals "-main" nil)]
                (when (some? (x/root-fn-form bref))
                  bref))))]
    (when-some [bref (main-function)]
      (let [main-mtd (rt/mtd-of* rt/void (.arrayType rt/String))
            flags (bit-or Classfile/ACC_PUBLIC Classfile/ACC_STATIC
                          Classfile/ACC_FINAL)
            xbh (cf/with-xbh [xb]
                  (let [mtd (MethodTypeDesc/of rt/object rt/IFn rt/object)]
                    (-> (cf/ld-insn xb (x/deref-load bref))
                        (.aload 0)
                        (.invokestatic rt/RT "apply" mtd)
                        (.pop)
                        (.return_))))]
        (.withMethodBody cb "main" main-mtd flags xbh)))))

(defn- builder-capstone ^Consumer [^SegmState segm ^Namespace nmsp]
  (let [requires-xb (cf/with-xbh [xb]
                      (let [s (if (nmsp/core-lib? nmsp)
                                "" ;suppress internal details of core lib
                                (str/join "," (sort (.req-strs nmsp))))]
                        (-> xb (.constantInstruction s) (.areturn))))]
    (cf/with-cbh [cb]
      (-> (.withFlags cb Classfile/ACC_PUBLIC)
          (.withSuperclass (segment-cld segm -1))
          (with-force-clinit)
          (.withMethodBody rt/name-requires rt/mtd-String-void
                           (bit-or Classfile/ACC_PUBLIC Classfile/ACC_STATIC
                                   Classfile/ACC_FINAL)
                           requires-xb)
          (with-main segm)))))

(defn- build-deftype ^ClassDef [^DeftypeDef dtdef]
  (letfn [(method-cbh [^MethodDef mdef]
            (cf/with-cbh [cb]
              (let [at (.at mdef)
                    this-class (-> dtdef .cdef .ch-info .thisClass)
                    ld-this (cf/ld-st-receiver this-class
                                               (name (.this-name at)))
                    xbh (cf/with-xbh [xb]
                          (.deliver-load (.this-bref mdef) ld-this)
                          (cf/st-insn xb ld-this true) ;emit LocalVariable entry
                          (bytecode/emit-body xb ld-this at 0
                                              (.body-expr mdef)))]
                (.withMethodBody cb (.method-name at) (x/at-mtd at)
                                 (.flags mdef) xbh))))]
    (let [cdef (.cdef dtdef)]
      (cf/with-methods cdef (map method-cbh (.method-defs dtdef))))))

(defn- mk-capstone ^Namespace [^NmspIO nmsp-io ^Ctx ctx
                               ^IPersistentMap provided-nmsp
                               ^IPersistentSet req-strs ^Class capstone]
  (let [publics (.extract-publics nmsp-io (.get-known-ns ctx) capstone)
        ;; do not re-export namespaces from `provided-nmsp`, because
        ;; this would cause obsoleted versions of the core namespace
        ;; to reach downstream namespaces like tinyclj.java.io
        kns (-> (reduce dissoc (.get-known-ns ctx) (keys provided-nmsp))
                (assoc (.ns-str ctx) publics))]
    (Namespace. nil nil nil ;clear `provided-nmsp`, `ctx`, `top-level-nmsp-io`
                req-strs capstone kns)))

(defn- mk-first-segm ^SegmState [^NmspIO nmsp-io ^Ctx ctx]
  (let [cld (ClassDesc/of (.ns-str ctx)
                          (str segment-class-prefix first-segm-id))]
    (SegmState. ctx nmsp-io first-segm-id cld [] (ArrayDeque.) [])))

(defn- emit-segments ^Namespace [^SegmState segm
                                 ^StructuredTaskScope nmsp-task-scope]
  (letfn [(take-msg ^Msg [^BlockingQueue q]
            (.take q))
          (schedule-fn-class ^SegmState [^SegmState segm ^FnCode fnc]
            (if-some [cbh (.fn-cbh (.emit-plan fnc))]
              (with-fn-class-fut segm
                (.fork-task (.nmsp-io segm) nmsp-task-scope
                            (^Callable fn []
                             (.produce-class (.nmsp-io segm)
                                             ^ClassDesc (.ld-clx fnc) cbh))
                            cfg/fork-work?))
              segm))
          (schedule-fn-classes ^SegmState [^SegmState segm ^TopLevelForm tlf]
            (let [segm (with-tlf segm tlf)
                  fncs (map #(-> ^FnSpec % .fn-form .!fnc) (.fn-specs tlf))]
              (doseq [^FnCode fnc fncs :let [ep (.emit-plan fnc)]]
                (when-some [ch-info (.fn-class-hierarchy-info ep)]
                  (.register-ch-info! (.nmsp-io segm) ch-info)))
              (reduce schedule-fn-class segm fncs)))
          (delayed-but-ready ^DelayedMacroFn [^SegmState segm]
            (when-some [mfn ^DelayedMacroFn (.peekFirst (.!delayed-macros segm))]
              (when (.realized? (.bref mfn))
                mfn)))
          (load-bref ^Object [^CompileIO compile-io ^BindingRef bref]
            (.invoke-global-mh compile-io
                               (.mh-if-global (x/deref-load bref)
                                              (.lookup-in-pkg compile-io))))
          (write-segment ^SegmState [^SegmState segm ^boolean force-clinit?]
            (if (and (not force-clinit?) (zero? (count (.tlfv segm))))
              segm                    ;nothing to do for empty segment
              ;; Note: There is no point to move the segment class into
              ;; a future, because it is immediately required -- either
              ;; for a macro value or for namespace completion.
              (let [segm-cld (segment-cld segm 0)
                    cbh (builder-segment segm segm-cld force-clinit?)
                    ;; macros from this segment class can be invoked
                    ;; once it is defined: make sure there are no
                    ;; pending dependencies
                    segm (with-collect-fn-classes segm)
                    cbd (.produce-class (.nmsp-io segm) segm-cld cbh)]
                (loop []
                  (when-some [mfn (delayed-but-ready segm)]
                    (when-not (.complete (.value-promise mfn)
                                         (load-bref (-> segm .ctx .compile-io)
                                                    (.bref mfn)))
                      (throw (IllegalStateException.)))
                    (.removeFirst (.!delayed-macros segm))
                    (recur)))
                (with-next-segm segm))))
          (write-and-define ^SegmState [^SegmState segm ^ClassDef cdef
                                        ^CompletableFuture promise]
            (.register-ch-info! (.nmsp-io segm) (.ch-info cdef))
            (let [cbh (cf/with-cbh [cb]
                        (-> (.withFlags cb (.flags cdef))
                            (.withSuperclass (-> cdef .ch-info .superClass))
                            (.withInterfaceSymbols (.itfs cdef)))
                        (run! #(.accept ^Consumer % cb) (.cb-handlerv cdef)))
                  this-class (-> cdef .ch-info .thisClass)
                  cl (.produce-class (.nmsp-io segm) this-class cbh)]
              (.complete promise cl)
              segm))
          (write-capstone ^Namespace [^SegmState segm ^Namespace nmsp]
            (let [nmsp-io (.nmsp-io segm)
                  cl (.produce-class nmsp-io (capstone-cld segm)
                                     (builder-capstone segm nmsp))]
              (mk-capstone nmsp-io (.ctx nmsp) (.provided-nmsp nmsp)
                           (.req-strs nmsp) cl)))
          
          (fn-specs-from-methods ^IPersistentVector [mdefs ^SegmState segm]
            (reduce
             (fn collect-fn-specs [acc ^MethodDef mdef]
               (let [body (.body-expr mdef)
                     tlf (prepare/collect-fn-info body)]
                 (into acc (.fn-specs tlf))))
             [] mdefs))
          (complete-req! ^SegmState [^SegmState segm ^int task x
                                     ^CompletableFuture promise]
            (condp = task
              ctx/msg-emit-tlf
              (let [tlf (prepare/collect-fn-info x)]
                (prepare/prepare-fns! (.segm-cld segm) (.fn-specs tlf))
                (prepare/prepare-globals! (.segm-cld segm) (.global-bs tlf))
                (cond-> (schedule-fn-classes segm tlf)
                  (and (not (-> segm .nmsp-io .compile-io .collect-macro-definitions?))
                       (some? (delayed-but-ready segm)))
                  (write-segment false)))

              ctx/msg-macro-of-next-tlf
              (do (.addLast (.!delayed-macros segm) x)
                  segm)

              ctx/msg-flush-macro-definitions
              (do (assert (-> segm .nmsp-io .compile-io .collect-macro-definitions?))
                  (cond-> segm
                    (delayed-but-ready segm) (write-segment false)))
              
              ctx/req-define-class
              (if (instance? ClassDef x)
                (write-and-define segm ^ClassDef x promise)
                (let [dtdef ^DeftypeDef x
                      fn-specs (fn-specs-from-methods (.method-defs dtdef) segm)
                      tlf (TopLevelForm. fn-specs nil x/expr-empty)]
                  (prepare/prepare-fns! (.segm-cld segm) fn-specs)
                  (-> (schedule-fn-classes segm tlf)
                      (write-and-define (build-deftype dtdef) promise))))
              
              ctx/req-flush-namespace-segment
              (let [cl (write-segment segm true)]
                ;; segment class `cl` exists and can now be looked up
                (.complete promise (x/invoke-force-clinit (.segm-cld segm)))
                cl)
              
              ctx/msg-fatal-error
              (throw ^Throwable x)
              
              #_else (throw (IllegalStateException. (str task)))))]

    (let [msg (take-msg (-> segm .ctx .emit-q))]
      (if (= (.task msg) ctx/msg-close-queue)
        (-> segm (write-segment false) (write-capstone (.x msg)))
        (recur (complete-req! segm (.task msg) (.x msg) (.promise msg))
               nmsp-task-scope)))))

(defn mk-provided-nmsp
  ([]
   (reduce-kv nmsp/assoc-provided {} predefined/implicit-known-ns))
  ([^String ns-str ^IPersistentMap publics]
   (nmsp/assoc-provided (mk-provided-nmsp) ns-str publics)))

(defn- init-known-ns ^void [^Ctx ctx ^IPersistentMap provided-nmsp]
  (doseq [[ns-str nmsp] provided-nmsp]
    (assert (string? ns-str))
    (assert (instance? Namespace nmsp)))
  (let [primitive-publics (-> (get provided-nmsp cfg/primitive-ns-str)
                              (nmsp/publics-of cfg/primitive-ns-str))]
    (doto ctx
      ;; primitive namespace can be used without require-ing it
      (.merge-into-known-ns {cfg/primitive-ns-str primitive-publics})
      (.put-ns-alias cfg/primitive-ns-str cfg/primitive-ns-str))))

;; Writes this namespace's bytecode to class files.  Assumes that
;; somewhere up in the call chain (i.e. tclj0 or tclj1) any classes in
;; this namespace's output package directory have been deleted.  The
;; output directory is created if it does not exist.
;;
;; Note: Exceptions are reported in the order in which they occur in
;; the emitter thread.  The "compile namespace" thread can fork of an
;; arbitrary number of futures of its own, and the emitter retrieves
;; their result/exception in emit order.
(defn- emit-namespace ^Namespace [^SegmState segm ^IPersistentMap provided-nmsp
                                  ^StructuredTaskScope nmsp-task-scope]
  (let [ctx (.ctx segm)]
    (init-known-ns ctx provided-nmsp)
    
    (let [c-fn (^Callable fn []
                (try
                  (let [nmsp-io (.enter-source-file (.nmsp-io segm) (.ns-str ctx) true)
                        nmsp (nmsp/mk-nmsp provided-nmsp nmsp-io ctx)
                        nsd (nmsp/compile-thread nmsp ctx)]
                    ;; regular completion: pass back result in first
                    ;; `close-queue` message
                    (ctx/send-msg (.emit-q ctx) ctx/msg-close-queue nsd))
                  (catch java.lang.InterruptedException _
                    ;; emitter thread is shutting down and is not taking
                    ;; any more messages: exit without sending anything
                    nil)
                  (catch Throwable t
                    (ctx/send-msg (.emit-q ctx) ctx/msg-fatal-error t))))
          c-thread (.fork-task (.nmsp-io segm) nmsp-task-scope c-fn true)
          nmsp (emit-segments segm nmsp-task-scope)]
      (.get c-thread)                   ;pick up any exceptions
      nmsp)))

;;; ------------------------------------------------------------------------

(letfn [(extract-req-strs ^"[Ljava.lang.String;" [^Class cl]
          (let [s (-> (.getDeclaredMethod cl rt/name-requires)
                      ^String (.invoke nil))]
            (if (= s "")
              (new "[Ljava.lang.String;" 0)
              (into-array String (str/split s #",")))))]
  (defn import-from-capstone ^Namespace [^BuildIO env
                                         ^NmspBuilder nmsp-builder
                                         ^IPersistentMap provided-nmsp
                                         ^Class capstone]
    (let [nmsp-io (.nmsp-io env capstone nil)
          ctx (ctx/mk-ctx* {} {} (.getPackageName capstone)
                           (.compile-io nmsp-io) nil)]
      (init-known-ns ctx provided-nmsp)
      
      ;; keep in sync with namespace/add-require-deps
      (let [ns-str (.getPackageName capstone)
            req-strs (extract-req-strs capstone)
            n (count req-strs)
            a (new objects n)
            apublics (new "[Lclojure.lang.IPersistentMap;" n)]
        ;; schedule namespaces in parallel
        (dotimes [i n]
          (let [req-str (aget req-strs i)]
            (aset a i (or (get provided-nmsp req-str)
                          (.schedule nmsp-builder req-str provided-nmsp)))))
        ;; wait for and pick up namespace outcomes
        (dotimes [i n]                  ;avoid stack frame spamming
          (let [ns-str (aget req-strs i)]
            (aset apublics i (-> (nmsp/nmsp-of (aget a i) ns-str)
                                 (nmsp/publics-of ns-str)))))
        ;; collect all "require"d globals and then add any new globals
        ;; to this namespace
        (loop [publics-map {}, i 0]
          (if (= i n)
            (.merge-into-known-ns ctx publics-map)
            (let [ns-str (aget req-strs i)
                  ekns (.exported-known-ns (nmsp/nmsp-of (aget a i) ns-str))]
              (recur (merge publics-map ekns) (inc i)))))
        (mk-capstone nmsp-io ctx provided-nmsp (into #{} req-strs) capstone)))))

;;; ------------------------------------------------------------------------

(defn compile-and-emit ^Namespace [^BuildIO env ^String ns-str
                                   ^NmspBuilder nmsp-builder
                                   ^IPersistentMap provided-nmsp]
  (let [nmsp-task-scope (StructuredTaskScope.)]
    (try
      (let [arity-task-scope (when-not (.deterministic-namespace-compile? nmsp-builder)
                               nmsp-task-scope)
            nmsp-io (.nmsp-io env ns-str nmsp-builder)
            tl-ctx (ctx/mk-ctx* (.initial-globals nmsp-io)
                                (.initial-imports nmsp-io)
                                ns-str (.compile-io nmsp-io) arity-task-scope)]
        (-> (mk-first-segm nmsp-io tl-ctx)
            (emit-namespace provided-nmsp nmsp-task-scope)))
      (catch Throwable t
        (.shutdown nmsp-task-scope)     ;make join return immediately
        (throw t))
      (finally
        (.joinUntil nmsp-task-scope (-> (Instant/now) (.plusSeconds 5)))
        (.close nmsp-task-scope)))))
