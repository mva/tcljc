(ns tcljc.emitter.export
  (:require [tcljc.expr :as x])
  (:import (tcljc.expr Expr BindingRef ValueRef MacroRef AliasRef FnForm)
           (clojure.lang IPersistentMap)
           (java.lang.invoke MethodHandle)))

;;; FIXME... the Classfile API may offer the option to move the
;;; exported entities into a private ConstantPool (dropping the bulk
;;; of the namespace in the process) and simply use BindingRef as part
;;; of the publics map

;; (deftype FnDesc [^"[Ljava.lang.invoke.MethodHandle;" amhd])

;; (deftype GlobalDesc [^String nm
;;                      ^String ns-str
;;                      ^boolean mutable?
;;                      ^boolean def-var?
;;                      ^FnDesc fn-desc    ;optional
;;                      ])

;; (deftype MacroDesc [^GlobalDesc macro-impl
;;                     ^Object macro-value]) ;GlobalDesc, AliasDesc, or nil

;; (deftype AliasDesc [^String nm
;;                     ^String ns-str
;;                     ^String aliased-nm
;;                     ^String aliased-n-str])



;; (defn export-nsd [^Stage st nsd ^String ns-str ^IPersistentMap globals]
;;   (letfn [(exported? ^boolean [entry]
;;             (let [bref ^BindingRef (val entry)]
;;               (and (= ns-str (.ns-str bref)) (not (x/b-private? bref)))))

;;           (export-fn-form ^FnDesc [^FnForm fn-form]
;;             (when (some? fn-form)
;;               (let [aca (-> fn-form .!fnc .arity-code-array (x/aca-by-n))
;;                     n (alength aca)
;;                     a (new "[Ljava.lang.invoke.MethodHandle;" n)
;;                     l (.lookup-in-pkg st)]
;;                 (dotimes [i n]
;;                   (let [insn (.load-mh-ext (aget aca i))
;;                         mhd (ep/describe (.ep st) (.epi insn))]
;;                     (aset a i ^MethodHandle (.resolveConstantDesc mhd l))))
;;                 (FnDesc. a))))
;;           (export-value-ref ^GlobalDesc [^ValueRef bref]
;;             (GlobalDesc. (str (x/sname bref)) (.ns-str bref)
;;                          (x/b-mutable? bref)
;;                          (x/b-def-var? bref)
;;                          (export-fn-form (.to-fn-form bref))))
;;           (export-macro-ref ^MacroDesc [^MacroRef bref]
;;             (assert (not (x/b-mutable? bref)))
;;             (assert (not (x/b-def-var? bref)))
;;             (MacroDesc. (export-value-ref (.macro-impl bref))
;;                         (when-some [x (.macro-value bref)]
;;                           (export x))))
;;           (export-alias-ref ^AliasDesc [^AliasRef bref]
;;             (assert (not (x/b-mutable? bref)))
;;             (assert (not (x/b-def-var? bref)))
;;             (let [src (.alias-for bref)]
;;               (AliasDesc. (str (x/sname bref)) (.ns-str bref)
;;                           (str (x/sname src)) (.ns-str src))))

;;           (export ^Object [^BindingRef bref]
;;             (assert (not (x/b-private? bref)))
;;             (condp instance? bref
;;               ValueRef (export-value-ref ^ValueRef bref)
;;               MacroRef (export-macro-ref ^MacroRef bref)
;;               AliasRef (export-alias-ref ^AliasRef bref)
;;               #_else (throw (IllegalArgumentException. (str (class bref))))))]
;;     (let [publics (into []
;;                         (comp (filter exported?) (map #(export (val %))))
;;                         (sort-by key globals))]
;;       #_(prn :published-nsd (count publics))
;;       (assoc nsd :publics-desc publics))))
