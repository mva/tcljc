(ns tcljc.main.tclj0
  (:require
   [tcljc.config :as cfg]
   [tcljc.emitter :as em]
   [tcljc.main.options :as options]
   [tcljc.main.efmt :as efmt]
   [tcljc.main.invoke :as invoke]
   [tinyclj.string :as str])
  (:import
   (tcljc.main.options Options)
   (clojure.lang IPersistentMap ExceptionInfo)
   (java.nio.file Path Files)))

(defn- class-file? ^boolean [^Path x]
  (str/ends-with? (.toString x) cfg/class-suffix))

(defn wipe-dest-dir [^Options opts]     ;only deletes class files
  (when (.dest-dir opts)
    (doseq [^Path x (cfg/file-seq (.dest-dir opts))
            :when (class-file? x)]
      #_(prn :wipe-dest-dir (.toString x))
      (Files/delete x))))

(defn build-all ^IPersistentMap [^Options opts ^boolean load-from-dest-dir?]
  (let [app-ld (cfg/app-class-loader (.parent-classloader opts) (.sourcev opts))
        all-nmsps (options/target-ns-strs opts)

        rt-lookup (cfg/get-rt-lookup app-ld)
        dyn-sourcev (if (and load-from-dest-dir? (some? (.dest-dir opts)))
                      [(.dest-dir opts)]
                      [])
        dyn-ld (cfg/dyn-class-loader app-ld dyn-sourcev)
        provided-nmsp (em/mk-provided-nmsp)]
    (-> (em/mk-build-env app-ld (.dest-dir opts) dyn-ld provided-nmsp)
        (em/emit-namespaces all-nmsps))))

(defn run ^boolean [^Options opts]
  (options/print-options opts)
  (wipe-dest-dir opts)       ;wipe before any classloaders are created
  (try
    (-> (time (build-all opts false))
        (invoke/invoke-and-report opts))
    (catch ExceptionInfo e
      (efmt/print-emap e)
      false)))
