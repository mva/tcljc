(ns tcljc.main.tclj1
  (:require
   [tcljc.config :as cfg]
   [tcljc.wrong :as wrong]
   [tcljc.emitter :as em]
   [tcljc.main.watcher :as watcher]
   [tcljc.main.options :as options]
   [tcljc.main.efmt :as efmt]
   [tcljc.main.invoke :as invoke]
   [tcljc.main.tclj0 :as tclj0])
  (:import
   (tcljc.main.options Options)
   (clojure.lang IPersistentMap ExceptionInfo)
   (java.util.function Consumer)))

;;; Transitively remove all namespaces from `dep-map` for which
;;; `pred-good` returns false, and delete all of their associated
;;; class files.
(defn- drop-bad-namespaces! ^IPersistentMap [^IPersistentMap dep-map
                                             ^Options opts pred-good]
  (let [!known-good (java.util.HashMap.)]
    (letfn [(known-good? [ns-str]
              (if-some [x (.get !known-good ns-str)] ;do not use `or` here
                x                        
                (let [dep-info (get dep-map ns-str)
                      good? (object (and ^boolean (pred-good dep-info)
                                         (every? known-good?
                                                 (:req-strs dep-info))))]
                  ;; note: imported class files have no req-strs and
                  ;; are implicitly "good"
                  (.put !known-good ns-str good?)
                  good?)))]
      (reduce-kv (fn [acc ns-str _]
                   (if (known-good? ns-str)
                     acc
                     (do (cfg/delete-package-classes (.dest-dir opts) ns-str)
                         (dissoc acc ns-str))))
                 dep-map dep-map))))

;; Returns the dependency map of all completed(!) namespaces.  On
;; return, there is no class file output from namespaces that were not
;; compiled successfully.
(defn build-pass ^IPersistentMap [^Options opts ^Consumer on-success
                                  ^IPersistentMap prior-completed-map]
  (letfn [(try-build ^IPersistentMap []
            (let [nmsp-map (time (tclj0/build-all opts true))
                  dep-map (em/dependency-map nmsp-map)]
              (try
                (.accept on-success nmsp-map) ;requires nmsp-map, not dep-map
                dep-map
                (catch Throwable t
                  (throw (wrong/assoc-dep-map t dep-map))))))
          (try-build-and-report ^IPersistentMap []
            (try
              (try-build)
              (catch ExceptionInfo e
                (efmt/print-emap e)
                (:emitter/namespaces (ex-data e)))
              (finally                 ;use finally to preserve result
                (println))))
          (keep-across-import [prior build]
            ;; preserve old rpaths and req-strs info if this namespace
            ;; was imported from class files instead of being compiled
            (if (em/imported-namespace? build)
              (or prior {})  ;we may already know about this namespace
              build))]
    (let [dep-map (try-build-and-report)]
      (-> (merge-with keep-across-import prior-completed-map dep-map)
          (drop-bad-namespaces! opts em/completed-namespace?)))))

(defn- mk-invoke-targets ^Consumer [^Options opts]
  (^Consumer fn [nmsp-map]
   (let [resultv (invoke/invoke-until-failure nmsp-map opts true)]
     (println (invoke/completion-report opts resultv)))))

(defn run
  (^boolean [^Options opts]
   (run opts (mk-invoke-targets opts)))
  (^boolean [^Options opts ^Consumer on-success]
   (options/print-options opts)
   (when (nil? (.dest-dir opts))
     (options/abort "error: mode `--watch` requires a destination directory"))
   (tclj0/wipe-dest-dir opts)
   (loop [w (watcher/new-watcher (.sourcev opts))
          dep-map (build-pass opts on-success {})]
     (let [w (watcher/wait-for-changes w (.wait-after-change-ms opts))
           pred-modified (watcher/mk-modified? w)
           dep-map (->> (fn ^boolean [dep-info]
                          (not (some pred-modified (:rpaths dep-info))))
                        (drop-bad-namespaces! dep-map opts))]
       (recur w (build-pass opts on-success dep-map))))
   false))                                ;unreachable
