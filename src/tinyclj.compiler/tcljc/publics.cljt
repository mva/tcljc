(ns tcljc.publics
  (:require
   [tcljc.config :as cfg]
   [tcljc.runtime :as rt]
   [tcljc.javabase :as jb]
   [tcljc.classfile :as cf]
   [tcljc.expr :as x]
   [tcljc.macro :as macro]
   [tcljc.context :as ctx]
   [tcljc.predefined :as predefined])
  (:import
   (tcljc.expr FnForm FnCode Arity ArityCode Binding BindingRef ValueRef
               IEmitPlan FnMacroFn)
   (tcljc.context Ctx)
   (clojure.lang Symbol IPersistentMap)
   (java.lang.invoke MethodHandle MethodHandles$Lookup)
   (java.lang.reflect Field Method Member Modifier)))

(defn- mk-emit-import ^IEmitPlan [^boolean virtual?]
  (reify
    IEmitPlan
    (fn-value-const [_]
      (throw (IllegalStateException.)))
    (fn-value-instr [this xb bref-mapper]
      (throw (IllegalStateException.)))
    (fn-patch-instr [_ xb bref-mapper bref]
      (throw (IllegalStateException.)))

    (fn-class-hierarchy-info [_]
      (throw (IllegalStateException.)))
    (fn-cbh [_]
      (throw (IllegalStateException.)))
    (fn-methods [this cb]
      (throw (IllegalStateException.)))
    
    (invoke-arity-with-self? [_]
      virtual?)
    (arity-env [_ xb bref-mapper at]
      [])))

(def ^:private emit-statics-import (mk-emit-import false))
(def ^:private emit-virtuals-import (mk-emit-import true))

(defn- call-only-fn-form ^FnForm [^Class declared-tp ^boolean virtual?
                                  ^"[Ljava.lang.invoke.MethodHandle;" mhs]
  (letfn [(import-parameter ^Binding [^Class tp]
            (-> (x/local-ref x/lvl-outermost-fn nil tp x/b-parameter)
                (x/local-binding nil)))
          (import-arity ^Arity [^int i ^MethodHandle mh]
            (let [mt (.type mh)
                  pcount (cond->> (.parameterCount mt)
                           virtual? (dec))
                  ptypes (cond->> (seq (.parameterList mt))
                           virtual? (rest))
                  va? (.isVarargsCollector mh)]
              (Arity. (mapv import-parameter ptypes) (.returnType mt) pcount
                      va? va? nil nil nil -1 nil nil i)))
          (import-arity-code ^ArityCode [^int i ^MethodHandle mh ^Arity at]
            (let [mhd (.get (.describeConstable mh))]
              (ArityCode. at nil nil mhd nil false)))]
    (let [ep (if virtual? emit-virtuals-import emit-statics-import)
          ac (new "[Ltcljc.expr.Arity;" (alength mhs))]
      (dotimes [i (alength ac)]
        (aset ac i (import-arity i (aget mhs i))))
      (let [fn-form (x/fn-form-fct nil declared-tp x/lvl-outermost-fn nil
                                   (vec ac))
            fnc (.!fnc fn-form)
            aca (.arity-code-array fnc)]
        (.mark-used-as-value fnc)
        (.set-ld-clx fnc declared-tp)
        (.set-emit-plan fnc ep)
        (dotimes [i (alength aca)]
          (aset aca i (import-arity-code i (aget mhs i) (aget ac i))))
        fn-form))))

(defn- import-fn-form ^FnForm [^MethodHandles$Lookup lookup-in-pkg
                               ^MethodHandle arity-handles-mh
                               ^Class declared-tp ^Object value]
  (when-some [mhs ^"[Ljava.lang.invoke.MethodHandle;"
              (.invokeExact arity-handles-mh lookup-in-pkg declared-tp value)]
    (let [static? (jb/same-classname? rt/clnm-static-fn (.getClass value))]
      (call-only-fn-form declared-tp (not static?) mhs))))

(deftype ImportedMacroFn [^MethodHandle apply-mh
                          ^Object f]
  FnMacroFn
  (expand [_ ctx form]
    ;; pass nil as `env` for now
    (macro/apply-macro apply-mh f form nil)))

(defn- add-publics [acc ^Class cl ^Ctx ctx ^MethodHandle arity-handles-mh
                    ^MethodHandle pdf-mh]
  (let [cld (rt/cd-of cl)
        postponed (java.util.HashMap.)]
    (letfn [(ns-str ^String []
              (.getPackageName cl))
            (global-nm ^String [^Member m]
              (when (Modifier/isPublic (.getModifiers m))
                (let [nm (.getName m)]
                  (when-not (.contains nm "~")
                    (cfg/demunge-name nm)))))
            (constant-init-x [^Class tp ^int mods ^Object value]
              (or (import-fn-form (.lookup-in-pkg ctx) arity-handles-mh tp value)
                  (when (and (not (Modifier/isTransient mods))
                             (cf/constant-loads-as-ldc? tp))
                    (x/const tp value))))
            (public-def-info ^objects [^Member member]
              ^objects (.invokeExact pdf-mh (.lookup-in-pkg ctx) member))
            (resolve-sym ^BindingRef [^Symbol sym acc-publics]
              (if (= (namespace sym) (ns-str))
                (get acc-publics (name sym)) ;nil if not yet known
                (-> (.valAt (.get-known-ns ctx) (namespace sym))
                    (get (name sym))
                    (java.util.Objects/requireNonNull))))

            (postpone! [acc-publics ^Symbol sym rf-bref]
              (let [nm (name sym)]
                (.put postponed nm (cons rf-bref (.get postponed nm)))
                acc-publics))
            (put! [acc-publics ^String nm ^BindingRef bref]
              (let [acc* (assoc acc-publics nm bref)]
                (if-some [rf-bref-seq (.get postponed nm)]
                  (do (.put postponed nm nil)
                      (reduce #(%2 %1 bref) acc* rf-bref-seq))
                  acc*)))
            
            (field-bref ^ValueRef [acc ^Field f ^String nm]
              (let [tp (.getType f)
                    mods (.getModifiers f)
                    redef? (not (Modifier/isFinal mods))
                    init-x (when-not redef?
                             (constant-init-x tp mods (.get f nil)))
                    bref (x/global-ref (symbol nil nm) (ns-str)
                                       tp redef? false init-x)
                    ld-st (cf/ld-st-static cld (.getName f) (rt/cd-of tp))]
                (.deliver-load bref ld-st)
                bref))
            (add-clojure-var [acc ^Field f ^String nm ^Class var-tp]
              (let [tp (.getType f)
                    mods (.getModifiers f)
                    redef? (not (Modifier/isFinal mods))
                    bref (x/global-ref (symbol nil nm) (ns-str)
                                       var-tp redef? true nil)
                    ld-st (cf/ld-st-static cld (.getName f) (rt/cd-of tp))]
                (.deliver-load bref ld-st)
                (put! acc nm bref)))
            (add-alias* [acc ^String nm ^BindingRef alias-for]
              (let [aref (x/alias-ref x/lvl-global (symbol nil nm) (ns-str)
                                      alias-for x/b-def)]
                (.deliver-load aref (x/deref-load alias-for))
                (put! acc nm aref)))
            (add-alias [acc ^String nm ^String sym-str]
              (let [sym (symbol sym-str)]
                (if-some [alias-for (resolve-sym sym acc)]
                  (add-alias* acc nm alias-for)
                  (postpone! acc sym (fn [acc ^BindingRef alias-for]
                                       (add-alias* acc nm alias-for))))))
            (add-field [acc ^Field f]
              (if-some [nm (global-nm f)]
                (if-some [pdf (public-def-info f)]
                  (case (aget pdf 0)
                    ":var" (add-clojure-var acc f nm (aget pdf 1))
                    ":alias" (add-alias acc nm (aget pdf 1))
                    ":macro" (add-macro acc nm pdf (field-bref acc f nm)))
                  (put! acc nm (field-bref acc f nm)))
                acc))
            
            (method-bref ^ValueRef [acc ^Method m ^String nm]
              (let [tp (.getReturnType m)
                    init-x (constant-init-x tp 0 (.invoke m nil))
                    bref (x/global-ref (symbol nil nm) (ns-str)
                                       tp false false init-x)
                    ld-st (cf/ld-st-method cld (.getName m) (rt/cd-of tp))]
                (.deliver-load bref ld-st)
                bref))
            (add-macro* [acc ^String nm ^objects pdf ^ValueRef mimpl
                         ^BindingRef mvalue]
              (let [f (aget pdf 1)
                    mfn (ImportedMacroFn. (.apply-mh ctx) f)
                    mref (x/macro-ref (symbol nil nm) (ns-str) mfn mvalue mimpl)]
                (put! acc nm mref)))
            (add-macro [acc ^String nm ^objects pdf ^ValueRef mimpl]
              (if-some [sym-str (aget pdf 2)]
                (let [sym (symbol sym-str)]
                  (if-some [mvalue (resolve-sym sym acc)]
                    (add-macro* acc nm pdf mimpl mvalue)
                    (postpone! acc sym (fn [acc ^BindingRef mvalue]
                                         (add-macro* acc nm pdf mimpl mvalue)))))
                (add-macro* acc nm pdf mimpl nil)))
            (add-method [acc ^Method m]
              (if (= (.getName m) rt/name-force-clinit)
                (let [cld (rt/describe-class cl)]
                  (assoc acc cfg/key-force-clinit (x/invoke-force-clinit cld)))
                (if-some [nm (when (zero? (.getParameterCount m)) ;skip main
                               (global-nm m))]
                  (if-some [pdf (public-def-info m)]
                    (case (aget pdf 0)
                      ":macro" (add-macro acc nm pdf (method-bref acc m nm)))
                    (put! acc nm (method-bref acc m nm)))
                  acc)))]
      (let [res (reduce add-field
                        (reduce add-method acc (.getDeclaredMethods cl))
                        (.getDeclaredFields cl))]
        (doseq [x postponed] (assert (nil? (val x))))
        res))))

(defn extract ^IPersistentMap [^MethodHandles$Lookup rt-lookup ^Ctx ctx
                               ^Class capstone]
  (letfn [(all-segments [acc ^Class cl]
            (if (identical? Object cl)
              acc
              (recur (cons cl acc) (.getSuperclass cl))))]
    (let [arity-handles-mh (ctx/resolve-mh rt-lookup rt/mhd-arityHandlesIfFn)
          pdf-mh (ctx/resolve-mh rt-lookup rt/mhd-publicDefInfo)]
      (reduce #(add-publics %1 %2 ctx arity-handles-mh pdf-mh)
              (predefined/initial-globals-for (.lookup-in-pkg ctx) (.ns-str ctx))
              (all-segments () capstone)))))
